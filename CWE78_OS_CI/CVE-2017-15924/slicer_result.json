[
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 0,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 98,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 1,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 98,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 2,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 101,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 3,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fopen",
    "line": 102,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 4,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 110,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 5,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 111,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 6,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 111,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 7,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 112,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 8,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 113,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 9,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 114,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 10,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 115,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 11,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 116,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 12,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 117,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 13,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 118,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 14,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 119,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 15,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 133,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 16,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 134,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    build_config(working_dir, server);\n",
      "    if (server->method) method = server->method;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 17,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 140,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 18,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 141,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 19,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 144,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 20,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 145,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 21,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 149,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 22,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 150,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 23,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 154,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 24,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 155,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 25,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 158,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 26,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 159,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 27,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 162,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 28,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 163,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 29,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 166,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 30,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 167,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 31,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 170,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 32,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 171,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 33,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 174,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 34,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 175,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 35,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 178,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 36,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 179,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 37,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 182,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 38,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 183,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 39,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 186,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 40,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 187,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 41,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 190,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 42,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 191,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 43,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 194,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 44,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 195,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 45,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 199,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 46,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 200,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 47,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 258,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "        LOGE(\"%s\", error_buf);\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "else\n",
      "                LOGE(\"invalid data: %s\", data);\n",
      "    json_value_free(obj);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 48,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 266,
    "label": -3,
    "slices": [
      "    char *data = get_data(buf, len);\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 49,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 272,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 50,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 274,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 51,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 278,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 52,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 280,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 53,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 282,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 54,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 284,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 55,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 286,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 56,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 288,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 57,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 290,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 58,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 292,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 59,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 294,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 60,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 296,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 61,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 298,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 62,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 300,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "parse_traffic",
    "Source": false,
    "Sink": false,
    "idx": 63,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 325,
    "label": -3,
    "slices": [
      "parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "        LOGE(\"%s\", error_buf);\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (value->type == json_integer) {\n",
      "                strncpy(port, name, 8);\n",
      "                *traffic = value->u.integer;\n",
      "    json_value_free(obj);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "parse_traffic",
    "Source": false,
    "Sink": false,
    "idx": 64,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 337,
    "label": -3,
    "slices": [
      "parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (value->type == json_integer) {\n",
      "                strncpy(port, name, 8);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 65,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 354,
    "label": -3,
    "slices": ["    memset(&hints, 0, sizeof(struct addrinfo));\n"]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 66,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getaddrinfo",
    "line": 361,
    "label": -3,
    "slices": [
      "create_and_bind(const char *host, const char *port, int protocol)\n",
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, listen_sock = -1;\n",
      "    s = getaddrinfo(host, port, &hints, &result);\n",
      "    if (s != 0) {\n",
      "        LOGE(\"getaddrinfo: %s\", gai_strerror(s));\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        if (listen_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "        if (s == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 67,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "socket",
    "line": 390,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, listen_sock = -1;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (listen_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n",
      "        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "            close(listen_sock);\n",
      "    if (rp == NULL) {\n",
      "    return listen_sock;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 68,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 410,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, listen_sock = -1;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (listen_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n",
      "        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "            close(listen_sock);\n",
      "    if (rp == NULL) {\n",
      "    return listen_sock;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "check_port",
    "Source": false,
    "Sink": false,
    "idx": 69,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 438,
    "label": -3,
    "slices": [
      "check_port(struct manager_ctx *manager, struct server *server)\n",
      "    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n",
      "    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n",
      "    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n",
      "    memset(sock_fds, 0, fd_count * sizeof(int));\n",
      "    for (int i = 0; i < manager->host_num; i++) {\n",
      "        if (manager->mode == UDP_ONLY) {\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "else\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n",
      "        if (both_tcp_udp) {\n",
      "            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n",
      "    for (int i = 0; i < fd_count; i++) {\n",
      "        if (sock_fds[i] > 0) {\n",
      "            close(sock_fds[i]);\n",
      "    ss_free(sock_fds);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "check_port",
    "Source": false,
    "Sink": false,
    "idx": 70,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 463,
    "label": -3,
    "slices": [
      "check_port(struct manager_ctx *manager, struct server *server)\n",
      "    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n",
      "    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n",
      "    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n",
      "    memset(sock_fds, 0, fd_count * sizeof(int));\n",
      "    for (int i = 0; i < manager->host_num; i++) {\n",
      "        LOGI(\"try to bind interface: %s, port: %s\", manager->hosts[i], server->port);\n",
      "        if (manager->mode == UDP_ONLY) {\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "else\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n",
      "        if (both_tcp_udp) {\n",
      "            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n",
      "    for (int i = 0; i < fd_count; i++) {\n",
      "        if (sock_fds[i] > 0) {\n",
      "            close(sock_fds[i]);\n",
      "    ss_free(sock_fds);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "add_server",
    "Source": false,
    "Sink": false,
    "idx": 71,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "system",
    "line": 486,
    "label": -3,
    "slices": [
      "add_server(struct manager_ctx *manager, struct server *server)\n",
      "    int ret = check_port(manager, server);\n",
      "    if (ret == -1) {\n",
      "    char *cmd = construct_command_line(manager, server);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 72,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 498,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 73,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 498,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 74,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 500,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 75,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fopen",
    "line": 501,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fclose(f);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 76,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fscanf",
    "line": 509,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 77,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 512,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 78,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "remove",
    "line": 513,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 79,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 521,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 80,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 521,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 81,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 523,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 82,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fopen",
    "line": 524,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 83,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fscanf",
    "line": 532,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 84,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 535,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 85,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 577,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 86,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "recvfrom",
    "line": 580,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "        LOGE(\"too large request: %d\", (int)r);\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "            if (server != NULL) {\n",
      "                destroy_server(server);\n",
      "                ss_free(server);\n",
      "        remove_server(working_dir, server->port);\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "            if (server != NULL) {\n",
      "                destroy_server(server);\n",
      "                ss_free(server);\n",
      "        remove_server(working_dir, server->port);\n",
      "        destroy_server(server);\n",
      "        ss_free(server);\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 87,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 596,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 88,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 622,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "        if (ret == -1) {\n",
      "            msg     = \"port is not available\";\n",
      "            msg_len = 21;\n",
      "else\n",
      "            msg     = \"ok\";\n",
      "            msg_len = 2;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 89,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 625,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 90,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 629,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 91,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sprintf",
    "line": 630,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 92,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 636,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 93,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 637,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 94,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 637,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 95,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 637,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 96,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 639,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 97,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 643,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 98,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sprintf",
    "line": 646,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "                pos = 0;\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 99,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 651,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 100,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcpy",
    "line": 652,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 101,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 653,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 102,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 654,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 103,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 658,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 104,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 675,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 105,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 678,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 106,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 688,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 107,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 694,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 108,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sprintf",
    "line": 695,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 109,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 701,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 110,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 704,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 111,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 708,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 112,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 714,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 113,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 722,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 114,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcpy",
    "line": 731,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 115,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 732,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 116,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 756,
    "label": -3,
    "slices": ["    memset(&hints, 0, sizeof(struct addrinfo));\n"]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 117,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getaddrinfo",
    "line": 762,
    "label": -3,
    "slices": [
      "create_server_socket(const char *host, const char *port)\n",
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, server_sock;\n",
      "    s = getaddrinfo(host, port, &hints, &result);\n",
      "    if (s != 0) {\n",
      "        LOGE(\"getaddrinfo: %s\", gai_strerror(s));\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        if (server_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "        if (s == 0) {\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 118,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "socket",
    "line": 790,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, server_sock;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (server_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "        close(server_sock);\n",
      "    if (rp == NULL) {\n",
      "    return server_sock;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 119,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 811,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, server_sock;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (server_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "        close(server_sock);\n",
      "    if (rp == NULL) {\n",
      "    return server_sock;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 120,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getopt_long",
    "line": 879,
    "label": -3,
    "slices": [
      "main(int argc, char **argv)\n",
      "    int i, c;\n",
      "    int pid_flags         = 0;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int server_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "    if (conf_path != NULL) {\n",
      "    USE_SYSLOG(argv[0], pid_flags);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 121,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 898,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int mtu        = 0;\n",
      "    int ipv6first  = 0;\n",
      "    static int nofile = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            mtu = atoi(optarg);\n",
      "    if (conf_path != NULL) {\n",
      "    struct manager_ctx manager;\n",
      "    manager.mtu             = mtu;\n",
      "    manager.plugin          = plugin;\n",
      "    manager.plugin_opts     = plugin_opts;\n",
      "    manager.ipv6first       = ipv6first;\n",
      "    manager.nofile = nofile;\n",
      "    struct ev_loop *loop = EV_DEFAULT;\n",
      "    int sfd;\n",
      "    manager.fd = sfd;\n",
      "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
      "    ev_io_start(loop, &manager.io);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 122,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 957,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    static int nofile = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            nofile = atoi(optarg);\n",
      "    if (conf_path != NULL) {\n",
      "    struct manager_ctx manager;\n",
      "    manager.nofile = nofile;\n",
      "    struct ev_loop *loop = EV_DEFAULT;\n",
      "    int sfd;\n",
      "    manager.fd = sfd;\n",
      "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
      "    ev_io_start(loop, &manager.io);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 123,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 1061,
    "label": -3,
    "slices": ["    signal(SIGPIPE, SIG_IGN);\n"]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 124,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 1062,
    "label": -3,
    "slices": ["    signal(SIGCHLD, SIG_IGN);\n"]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 125,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 1063,
    "label": -3,
    "slices": ["    signal(SIGABRT, SIG_IGN);\n"]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 126,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 1073,
    "label": -3,
    "slices": ["    memset(&manager, 0, sizeof(struct manager_ctx));\n"]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 127,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getpwuid",
    "line": 1105,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "        closedir(dp);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 128,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1107,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "        closedir(dp);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 129,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 1109,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 130,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "mkdir",
    "line": 1111,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 131,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1124,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 132,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1125,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 133,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 1142,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    if (conf != NULL) {\n",
      "        for (i = 0; i < conf->port_password_num; i++) {\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "            memset(server, 0, sizeof(struct server));\n",
      "            strncpy(server->port, conf->port_password[i].port, 8);\n",
      "            strncpy(server->password, conf->port_password[i].password, 128);\n",
      "            add_server(&manager, server);\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 134,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1143,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int fast_open  = 0;\n",
      "    int reuse_port = 0;\n",
      "    int mode       = TCP_ONLY;\n",
      "    int mtu        = 0;\n",
      "    int ipv6first  = 0;\n",
      "    static int nofile = 0;\n",
      "    int server_num = 0;\n",
      "    char *server_host[MAX_REMOTE_NUM];\n",
      "    char *nameservers[MAX_DNS_NUM + 1];\n",
      "    int nameserver_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            conf_path = optarg;\n",
      "    if (conf_path != NULL) {\n",
      "        conf = read_jconf(conf_path);\n",
      "        if (server_num == 0) {\n",
      "            server_num = conf->remote_num;\n",
      "            for (i = 0; i < server_num; i++)\n",
      "                server_host[i] = conf->remote_addr[i].host;\n",
      "        if (password == NULL) {\n",
      "            password = conf->password;\n",
      "        if (method == NULL) {\n",
      "            method = conf->method;\n",
      "        if (timeout == NULL) {\n",
      "            timeout = conf->timeout;\n",
      "        if (user == NULL) {\n",
      "            user = conf->user;\n",
      "        if (fast_open == 0) {\n",
      "            fast_open = conf->fast_open;\n",
      "        if (reuse_port == 0) {\n",
      "            reuse_port = conf->reuse_port;\n",
      "        if (conf->nameserver != NULL) {\n",
      "            nameservers[nameserver_num++] = conf->nameserver;\n",
      "        if (mode == TCP_ONLY) {\n",
      "            mode = conf->mode;\n",
      "        if (mtu == 0) {\n",
      "            mtu = conf->mtu;\n",
      "        if (plugin == NULL) {\n",
      "            plugin = conf->plugin;\n",
      "        if (plugin_opts == NULL) {\n",
      "            plugin_opts = conf->plugin_opts;\n",
      "        if (ipv6first == 0) {\n",
      "            ipv6first = conf->ipv6_first;\n",
      "        if (nofile == 0) {\n",
      "            nofile = conf->nofile;\n",
      "    if (conf != NULL) {\n",
      "        for (i = 0; i < conf->port_password_num; i++) {\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "            memset(server, 0, sizeof(struct server));\n",
      "            strncpy(server->port, conf->port_password[i].port, 8);\n",
      "            strncpy(server->password, conf->port_password[i].password, 128);\n",
      "            add_server(&manager, server);\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 135,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1144,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int fast_open  = 0;\n",
      "    int reuse_port = 0;\n",
      "    int mode       = TCP_ONLY;\n",
      "    int mtu        = 0;\n",
      "    int ipv6first  = 0;\n",
      "    static int nofile = 0;\n",
      "    int server_num = 0;\n",
      "    char *server_host[MAX_REMOTE_NUM];\n",
      "    char *nameservers[MAX_DNS_NUM + 1];\n",
      "    int nameserver_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            conf_path = optarg;\n",
      "    if (conf_path != NULL) {\n",
      "        conf = read_jconf(conf_path);\n",
      "        if (server_num == 0) {\n",
      "            server_num = conf->remote_num;\n",
      "            for (i = 0; i < server_num; i++)\n",
      "                server_host[i] = conf->remote_addr[i].host;\n",
      "        if (password == NULL) {\n",
      "            password = conf->password;\n",
      "        if (method == NULL) {\n",
      "            method = conf->method;\n",
      "        if (timeout == NULL) {\n",
      "            timeout = conf->timeout;\n",
      "        if (user == NULL) {\n",
      "            user = conf->user;\n",
      "        if (fast_open == 0) {\n",
      "            fast_open = conf->fast_open;\n",
      "        if (reuse_port == 0) {\n",
      "            reuse_port = conf->reuse_port;\n",
      "        if (conf->nameserver != NULL) {\n",
      "            nameservers[nameserver_num++] = conf->nameserver;\n",
      "        if (mode == TCP_ONLY) {\n",
      "            mode = conf->mode;\n",
      "        if (mtu == 0) {\n",
      "            mtu = conf->mtu;\n",
      "        if (plugin == NULL) {\n",
      "            plugin = conf->plugin;\n",
      "        if (plugin_opts == NULL) {\n",
      "            plugin_opts = conf->plugin_opts;\n",
      "        if (ipv6first == 0) {\n",
      "            ipv6first = conf->ipv6_first;\n",
      "        if (nofile == 0) {\n",
      "            nofile = conf->nofile;\n",
      "    if (conf != NULL) {\n",
      "        for (i = 0; i < conf->port_password_num; i++) {\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "            memset(server, 0, sizeof(struct server));\n",
      "            strncpy(server->port, conf->port_password[i].port, 8);\n",
      "            strncpy(server->password, conf->port_password[i].password, 128);\n",
      "            add_server(&manager, server);\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 136,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "socket",
    "line": 1155,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct manager_ctx manager;\n",
      "    struct ev_loop *loop = EV_DEFAULT;\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /*  Create server socket */\n",
      "        setnonblocking(sfd);\n",
      "    manager.fd = sfd;\n",
      "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
      "    ev_io_start(loop, &manager.io);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 137,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "remove",
    "line": 1163,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int server_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            manager_address = optarg;\n",
      "    if (manager_address == NULL) {\n",
      "        manager_address = \"127.0.0.1:8839\";\n",
      "        LOGI(\"using the default manager address: %s\", manager_address);\n",
      "    struct manager_ctx manager;\n",
      "    manager.manager_address = manager_address;\n",
      "    parse_addr(manager_address, &ip_addr);\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        struct sockaddr_un svaddr;\n",
      "        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 138,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 1169,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        memset(&svaddr, 0, sizeof(struct sockaddr_un));\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 139,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1171,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int server_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            manager_address = optarg;\n",
      "    if (manager_address == NULL) {\n",
      "        manager_address = \"127.0.0.1:8839\";\n",
      "        LOGI(\"using the default manager address: %s\", manager_address);\n",
      "    struct manager_ctx manager;\n",
      "    manager.manager_address = manager_address;\n",
      "    parse_addr(manager_address, &ip_addr);\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        struct sockaddr_un svaddr;\n",
      "        svaddr.sun_family = AF_UNIX;\n",
      "        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n"
    ]
  },
  {
    "FileName": "manager.c",
    "Caller": "add_server",
    "Source": false,
    "Sink": false,
    "idx": 140,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "system",
    "line": 486,
    "label": -3,
    "slices": [
      "add_server(struct manager_ctx *manager, struct server *server)\n",
      "    int ret = check_port(manager, server);\n",
      "    if (ret == -1) {\n",
      "    char *cmd = construct_command_line(manager, server);\n",
      "    strcat(cmd, 'STRCAT_TEST');\n"
    ]
  }
]
