# 📁 CVE-2018-6791

## 🔍 취약점 개요
**🔗 [커밋 링크](https://github.com/benemorius/plasma-workspace/commit/9db872df82c258315c6ebad800af59e81ffb9212)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2018-6791/)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/78.html)** 

> 5.12.0 이전 버전의 KDE Plasma Workspace프로그램의 soliduiserver/deviceserviceaction.cpp파일에서 어떤 기능에 있는 어떤 함수에서 발생한 볼륨 레이블에 '' 또는 $()가 포함된 vfat 썸드라이브를 장치 알리미를 통해 연결하고 마운트하면 셸 명령으로 해석되어 임의의 명령이 실행될 가능성이 있는 취약점입니다.
> 문제 예시 : "$(touch b)" (홈 폴더에 b라는 파일을 만든다.)

* **취약 조건**: 입력값 검증 없이 명령 실행 경로에 직접 사용됨
* **Sink**: runCommand(exec, QString(), m_service.icon(), 0) 함수 사용

## 분석 결과 요약
cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스만 고려했을 때, 

| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 1개       | 0개 | 1개 |

이중 Sink(`runCommand()` 함수) 관련 슬라이스는 0건 존재

\* cve 설명에 나온 취약한 함수(Caller) && Sink와 관련된 슬라이스 데이터만 추출


이 CVE 취약점을 유발하는 코드(sink:soliduiserver/deviceserviceaction.cpp:163)는 아래와 같다.
```
void DelayedExecutor::delayedExecute(const QString &udi)
{
    Solid::Device device(udi);

    QString exec = m_service.exec();
    MacroExpander mx(device);
    mx.expandMacros(exec);

    KRun::runCommand(exec, QString(), m_service.icon(), 0);
```
이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.
```
/* userDefinedServices는 KDesktopFileActions의 메소드인데 이는 외부 라이브러리에 있는 클래스이고, 파일에서 불러오는 것! 

`random.desktop` 파일 예시
[Desktop Entry]
Name=MyPlayer
Exec=myplayer %U
Icon=myplayer
Type=Application
Actions=Play,Edit

[Desktop Action Play]
Name=Play
Exec=myplayer --play %U
Icon=media-playback-start

[Desktop Action Edit]
Name=Edit
Exec=myplayer --edit %U
Icon=document-edit

위 파일에서 Exec 값이 m_service.exec() 값으로 반환되는 것으로 보인다.

*/
/* soliduiserver/soliduiserver.cpp:77 */
void SolidUiServer::showActionsDialog(const QString &udi,
                                      const QStringList &desktopFiles)
{
    if (m_udiToActionsDialog.contains(udi)) {
    QList<DeviceAction*> actions;
    foreach (const QString &desktop, desktopFiles) {
        const QString filePath = QStandardPaths::locate(QStandardPaths::GenericDataLocation, "solid/actions/"+desktop);

        QList<KServiceAction> services = KDesktopFileActions::userDefinedServices(filePath, true);

        foreach (const KServiceAction &service, services) {
            DeviceServiceAction *action = new DeviceServiceAction();
            action->setService(service);
            actions << action;
        }
    }

    // Only one action, execute directly
    if (actions.size()==1) {
        DeviceAction *action = actions.takeFirst();
        Solid::Device device(udi);
        action->execute(device);


/* soliduiserver/deviceserviceaction.cpp:95 */
void DeviceServiceAction::setService(const KServiceAction& service)
{
    DeviceAction::setIconName(service.icon());
    DeviceAction::setLabel(service.text());

    m_service = service;

/* soliduiserver/deviceserviceaction.h:80 */
class DeviceServiceAction : public DeviceAction
{
public:
    DeviceServiceAction();
    QString id() const override;
    void execute(Solid::Device &device) override;

    void setService(const KServiceAction& service);
    KServiceAction service() const;

private:
    KServiceAction m_service;
};

/* soliduiserver/deviceserviceaction.cpp:77 */
void DeviceServiceAction::execute(Solid::Device &device)
{
    new DelayedExecutor(m_service, device);

/* soliduiserver/deviceserviceaction.cpp:139 */
DelayedExecutor::DelayedExecutor(const KServiceAction &service, Solid::Device &device): m_service(service)

/* soliduiserver/deviceserviceaction.cpp:163 */
void DelayedExecutor::delayedExecute(const QString &udi)
{
    Solid::Device device(udi);

    QString exec = m_service.exec();
    MacroExpander mx(device);
    mx.expandMacros(exec);

    KRun::runCommand(exec, QString(), m_service.icon(), 0);
```
이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

- cve 설명에 나온 문제를 일으키는 함수가 l_funcs 리스트에 있는 함수가 아니기 때문인지 추출이 되지 않음
- 해당 코드가 있는 함수 내부에 l_funcs 리스트에 있는 함수가 존재하지 않아 스니펫 생성이 안된것으로 보임

### 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출
없음

## 취약점 세부 사항

### 📁 관련 파일 소개
파일 한개 면, 작성 안하셔도 됩니다.
| 파일명            | 설명              |
| -------------- | --------------- |
| `before_deviceserviceaction.cpp` | 취약 코드 (수정 전) 포함 |
| `after_deviceserviceaction.cpp`  | 개선 코드 (수정 후) 포함 |

---

### ❗️ 취약 코드

**문제점**:
사용자 입력이 적절히 검증되지 않은 채로 `runCommand` 함수의 인자로 사용되어 **명령어 인젝션**이 발생할 수 있음.


#### Sink: `before_deviceserviceaction.cpp:155`
```c
void DelayedExecutor::delayedExecute(const QString &udi)
{
    Solid::Device device(udi);

    QString exec = m_service.exec();
    MacroExpander mx(device);
    mx.expandMacros(exec);

    KRun::runCommand(exec, QString(), m_service.icon(), 0);
    deleteLater();
}
```

### ✅ 개선 코드

**패치 위치**: `after_deviceserviceaction.cpp:155`

```c
void DelayedExecutor::delayedExecute(const QString &udi)
{
    Solid::Device device(udi);

    QString exec = m_service.exec();
    MacroExpander mx(device);
    mx.expandMacrosShellQuote(exec);

    KRun::runCommand(exec, QString(), m_service.icon(), 0);
    deleteLater();
}
```

**개선 방법**:
expandMacrosShellQuote(exec) 입력값을 검증해주는 함수 사용