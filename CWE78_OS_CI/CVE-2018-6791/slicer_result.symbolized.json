[{"FileName": "before_deviceserviceaction.cpp", "Caller": "DelayedExecutor :: DelayedExecutor", "Source": false, "Sink": false, "idx": 0, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "connect", "line": 146, "label": -3, "slices": ["        connect(access, &Solid::StorageAccess::setupDone,\n                this, &DelayedExecutor::_k_storageSetupDone);\n"], "tokenized": "connect(Var1,&CLASS1::CLASS2::Var2,\nthis ,&CLASS3::Var3); \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_set_icc_directory", "Source": false, "Sink": false, "idx": 1, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 88, "label": -3, "slices": ["gs_lib_ctx_set_icc_directory(const gs_memory_t *mem_gc, const char* pname,\n                             int dir_namelen)\n", "    char *result;\n", "    gs_lib_ctx_t *p_ctx = mem_gc->gs_lib_ctx;\n", "    gs_memory_t *p_ctx_mem = p_ctx->memory;\n", "    if (p_ctx->profiledir != NULL && strcmp(pname,DEFAULT_DIR_ICC) == 0) {\n", "    if (p_ctx->profiledir != NULL && p_ctx->profiledir_len > 0) {\n", "        if (strncmp(pname, p_ctx->profiledir, p_ctx->profiledir_len) == 0) {\n", "        gs_free_object(p_ctx_mem, p_ctx->profiledir,\n                       \"gs_lib_ctx_set_icc_directory\");\n", "        p_ctx->profiledir = NULL;\n", "        p_ctx->profiledir_len = 0;\n", "    if (result == NULL) {\n", "    strcpy(result, pname);\n", "    p_ctx->profiledir = result;\n", "    p_ctx->profiledir_len = dir_namelen;\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,const char *Var2,\nint  Var3)\nchar *Var4; \nSTRUCT2 *Var5=Var1->memberVar1; \nSTRUCT1 *Var6=Var5->memberVar1; \nif (Var5->memberVar2 != NULL &&strcmp(Var2,Var7) == 0){\nif (Var5->memberVar2 != NULL &&Var5->memberVar3>0){\nif (FUNC2(Var2,Var5->memberVar2,Var5->memberVar3) == 0){\nFUNC3(Var6,Var5->memberVar2,\nSTRING); \nVar5->memberVar2=NULL ; \nVar5->memberVar3=0; \nif (Var4 == NULL ){\nstrcpy(Var4,Var2); \nVar5->memberVar2=Var4; \nVar5->memberVar3=Var3; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_set_icc_directory", "Source": false, "Sink": false, "idx": 2, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 106, "label": -3, "slices": ["gs_lib_ctx_set_icc_directory(const gs_memory_t *mem_gc, const char* pname,\n                             int dir_namelen)\n", "                             int dir_namelen)\n", "    char *result;\n", "    gs_lib_ctx_t *p_ctx = mem_gc->gs_lib_ctx;\n", "    gs_memory_t *p_ctx_mem = p_ctx->memory;\n", "    if (p_ctx->profiledir != NULL && strcmp(pname,DEFAULT_DIR_ICC) == 0) {\n", "    if (p_ctx->profiledir != NULL && p_ctx->profiledir_len > 0) {\n", "        if (strncmp(pname, p_ctx->profiledir, p_ctx->profiledir_len) == 0) {\n", "    result = (char*) gs_alloc_bytes(p_ctx_mem, dir_namelen+1,\n                                     \"gs_lib_ctx_set_icc_directory\");\n", "    if (result == NULL) {\n", "    strcpy(result, pname);\n", "    p_ctx->profiledir = result;\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,const char *Var2,\nint  Var3)\nint  Var3)\nchar *Var4; \nSTRUCT2 *Var5=Var1->memberVar1; \nSTRUCT1 *Var6=Var5->memberVar1; \nif (Var5->memberVar2 != NULL &&strcmp(Var2,Var7) == 0){\nif (Var5->memberVar2 != NULL &&Var5->memberVar3>0){\nif (FUNC2(Var2,Var5->memberVar2,Var5->memberVar3) == 0){\nVar4=(char *) FUNC3(Var6,Var3+1,\nSTRING); \nif (Var4 == NULL ){\nstrcpy(Var4,Var2); \nVar5->memberVar2=Var4; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_set_default_device_list", "Source": false, "Sink": false, "idx": 3, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 129, "label": -3, "slices": ["gs_lib_ctx_set_default_device_list(const gs_memory_t *mem, const char* dev_list_str,\n                        int list_str_len)\n", "                        int list_str_len)\n", "    char *result;\n", "    gs_lib_ctx_t *p_ctx = mem->gs_lib_ctx;\n", "    gs_memory_t *ctx_mem = p_ctx->memory;\n", "    result = (char *)gs_alloc_bytes(ctx_mem, list_str_len + 1,\n             \"gs_lib_ctx_set_default_device_list\");\n", "    if (result) {\n", "      memcpy(result, dev_list_str, list_str_len);\n", "      result[list_str_len] = '\\0';\n", "      p_ctx->default_device_list = result;\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,const char *Var2,\nint  Var3)\nint  Var3)\nchar *Var4; \nSTRUCT2 *Var5=Var1->memberVar1; \nSTRUCT1 *Var6=Var5->memberVar1; \nVar4=(char *) FUNC2(Var6,Var3+1,\nSTRING); \nif (Var4){\nmemcpy(Var4,Var2,Var3); \nVar4[Var3]=0; \nVar5->memberVar2=Var4; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_get_default_device_list", "Source": false, "Sink": false, "idx": 4, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 151, "label": -3, "slices": ["gs_lib_ctx_get_default_device_list(const gs_memory_t *mem, char** dev_list_str,\n                        int *list_str_len)\n", "                        int *list_str_len)\n", "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n", "        *dev_list_str = mem->gs_lib_ctx->default_device_list;\n", "else\n", "        *dev_list_str = (char *)gs_dev_defaults;\n", "    *list_str_len = strlen(*dev_list_str);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,char **Var2,\nint *Var3)\nint *Var3)\nif (Var1&&Var1->memberVar1&&Var1->memberVar1->memberVar1){\n*Var2=Var1->memberVar1->memberVar1; \nelse \n*Var2=(char *) Var4; \n*Var3=strlen(*Var2); \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_init", "Source": false, "Sink": false, "idx": 5, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 287, "label": -3, "slices": ["int gs_lib_ctx_init(gs_lib_ctx_t *ctx, gs_memory_t *mem)\n", "    gs_lib_ctx_t *pio = NULL;\n", "    gs_globals *globals;\n", "    if (mem->gs_lib_ctx) /* one time initialization */\n", "    pio = (gs_lib_ctx_t*)gs_alloc_bytes_immovable(mem,\n                                                  sizeof(gs_lib_ctx_t),\n                                                  \"gs_lib_ctx_init\");\n", "    if(pio == NULL)\n", "    memset(pio, 0, sizeof(*pio));\n", "    if (ctx != NULL) {\n", "        pio->core = ctx->core;\n", "        gx_monitor_enter((gx_monitor_t *)(pio->core->monitor));\n", "        pio->core->refs++;\n", "        gx_monitor_leave((gx_monitor_t *)(pio->core->monitor));\n", "else\n", "        pio->core = (gs_lib_ctx_core_t *)gs_alloc_bytes_immovable(mem,\n                                                                  sizeof(gs_lib_ctx_core_t),\n                                                                  \"gs_lib_ctx_init(core)\");\n", "        if (pio->core == NULL) {\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        memset(pio->core, 0, sizeof(*pio->core));\n", "        pio->core->globals = globals;\n", "        pio->core->fs = (gs_fs_list_t *)gs_alloc_bytes_immovable(mem,\n                                                                 sizeof(gs_fs_list_t),\n                                                                 \"gs_lib_ctx_init(gs_fs_list_t)\");\n", "        if (pio->core->fs == NULL) {\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->cal_ctx = cal_init(&cal_allocs, mem);\n", "        if (pio->core->cal_ctx == NULL) {\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->fs->fs.open_file = fs_file_open_file;\n", "        pio->core->fs->fs.open_pipe = NULL;\n", "        pio->core->fs->fs.open_scratch = fs_file_open_scratch;\n", "        pio->core->fs->fs.open_printer = fs_file_open_printer;\n", "        pio->core->fs->secret = NULL;\n", "        pio->core->fs->memory = mem;\n", "        pio->core->fs->next   = NULL;\n", "        pio->core->monitor = gx_monitor_alloc(mem);\n", "        if (pio->core->monitor == NULL)\n", "        pio->core->refs = 1;\n", "        pio->core->memory = mem;\n", "        gs_lib_ctx_get_real_stdio(&pio->core->fstdin, &pio->core->fstdout, &pio->core->fstderr );\n", "        pio->core->stdin_is_interactive = true;\n", "        pio->core->gs_next_id = 5; /* Cloned contexts share the state */\n", "        pio->core->scanconverter = GS_SCANCONVERTER_DEFAULT;\n", "        pio->core->cms_context = gscms_create(mem);\n", "        if (pio->core->cms_context == NULL) {\n", "            gx_monitor_free((gx_monitor_t *)(pio->core->monitor));\n", "            cal_fin(pio->core->cal_ctx, mem);\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "    pio->memory               = mem;\n", "    mem->gs_lib_ctx = pio;\n", "    pio->profiledir = NULL;\n", "    pio->profiledir_len = 0;\n", "    pio->icc_color_accuracy = MAX_COLOR_ACCURACY;\n", "    if (gs_lib_ctx_set_icc_directory(mem, DEFAULT_DIR_ICC, strlen(DEFAULT_DIR_ICC)) < 0)\n", "    if (gs_lib_ctx_set_default_device_list(mem, gs_dev_defaults,\n                                           strlen(gs_dev_defaults)) < 0)\n", "    if (sjpxd_create(mem))\n", "    pio->client_check_file_permission = NULL;\n", "    gp_get_realtime(pio->real_time_0);\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->name_table_root))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->io_device_table_root))\n"], "tokenized": "int FUNC1(STRUCT1 *Var1,STRUCT2 *Var2)\nSTRUCT1 *Var3=NULL ; \nSTRUCT3 *Var4; \nif (Var2->memberVar1)/*Var5  STRUCT4 STRUCT5 */\nVar3=(STRUCT1 *) FUNC2(Var2,\nsizeof (STRUCT1),\nSTRING); \nif (Var3 == NULL )\nmemset(Var3,0,sizeof (*Var3)); \nif (Var1 != NULL ){\nVar3->memberVar1=Var1->memberVar1; \nFUNC3((STRUCT6 *)(Var3->memberVar1->memberVar1)); \nVar3->memberVar1->STRUCT7  Var6; \nFUNC4((STRUCT6 *)(Var3->memberVar1->memberVar1)); \nelse \nVar3->memberVar1=(STRUCT8 *) FUNC2(Var2,\nsizeof (STRUCT8),\nSTRING); \nif (Var3->memberVar1 == NULL ){\nFUNC5(Var2,Var3,STRING); \nmemset(Var3->memberVar1,0,sizeof (*Var3->memberVar1)); \nVar3->memberVar1->memberVar2=memberVar2; \nVar3->memberVar1->memberVar3=(STRUCT9 *) FUNC2(Var2,\nsizeof (STRUCT9),\nSTRING); \nif (Var3->memberVar1->memberVar3 == NULL ){\nFUNC5(Var2,Var3->memberVar1,STRING); \nFUNC5(Var2,Var3,STRING); \nVar3->memberVar1->memberVar4=FUNC6(&Var7,Var2); \nif (Var3->memberVar1->memberVar4 == NULL ){\nFUNC5(Var2,Var3->memberVar1->memberVar3,STRING); \nFUNC5(Var2,Var3->memberVar1,STRING); \nFUNC5(Var2,Var3,STRING); \nVar3->memberVar1->memberVar3->memberVar1.memberVar2=Var8; \nVar3->memberVar1->memberVar3->memberVar1.memberVar3=NULL ; \nVar3->memberVar1->memberVar3->memberVar1.memberVar4=Var9; \nVar3->memberVar1->memberVar3->memberVar1.memberVar5=Var10; \nVar3->memberVar1->memberVar3->memberVar6=NULL ; \nVar3->memberVar1->memberVar3->memberVar7=Var2; \nVar3->memberVar1->memberVar3->memberVar8=NULL ; \nVar3->memberVar1->memberVar1=FUNC7(Var2); \nif (Var3->memberVar1->memberVar1 == NULL )\nVar3->memberVar1->memberVar5=1; \nVar3->memberVar1->memberVar6=Var2; \nFUNC8(&Var3->memberVar1->memberVar7,&Var3->memberVar1->memberVar8,&Var3->memberVar1->memberVar9); \nVar3->memberVar1->memberVar10=true ; \nVar3->memberVar1->memberVar11=5; /*Var11  Var12  Var13  STRUCT10 STRUCT11 */\nVar3->memberVar1->memberVar12=Var14; \nVar3->memberVar1->memberVar13=FUNC9(Var2); \nif (Var3->memberVar1->memberVar13 == NULL ){\nFUNC10((STRUCT6 *)(Var3->memberVar1->memberVar1)); \nFUNC11(Var3->memberVar1->memberVar4,Var2); \nFUNC5(Var2,Var3->memberVar1->memberVar3,STRING); \nFUNC5(Var2,Var3->memberVar1,STRING); \nFUNC5(Var2,Var3,STRING); \nVar3->memberVar2=Var2; \nVar2->memberVar1=Var3; \nVar3->memberVar3=NULL ; \nVar3->memberVar4=0; \nVar3->memberVar5=Var15; \nif (FUNC12(Var2,Var16,strlen(Var16))<0)\nif (FUNC13(Var2,Var17,\nstrlen(Var17))<0)\nif (FUNC14(Var2))\nVar3->memberVar6=NULL ; \nFUNC15(Var3->memberVar7); \nif (FUNC16(Var2,&Var3->memberVar8))\nif (FUNC16(Var2,&Var3->memberVar9))\n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_init", "Source": false, "Sink": false, "idx": 6, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 302, "label": -3, "slices": ["int gs_lib_ctx_init(gs_lib_ctx_t *ctx, gs_memory_t *mem)\n", "    gs_lib_ctx_t *pio = NULL;\n", "    gs_globals *globals;\n", "    if (mem->gs_lib_ctx) /* one time initialization */\n", "    pio = (gs_lib_ctx_t*)gs_alloc_bytes_immovable(mem,\n                                                  sizeof(gs_lib_ctx_t),\n                                                  \"gs_lib_ctx_init\");\n", "    if(pio == NULL)\n", "    memset(pio, 0, sizeof(*pio));\n", "    if (ctx != NULL) {\n", "        pio->core = ctx->core;\n", "        gx_monitor_enter((gx_monitor_t *)(pio->core->monitor));\n", "        pio->core->refs++;\n", "        gx_monitor_leave((gx_monitor_t *)(pio->core->monitor));\n", "else\n", "        pio->core = (gs_lib_ctx_core_t *)gs_alloc_bytes_immovable(mem,\n                                                                  sizeof(gs_lib_ctx_core_t),\n                                                                  \"gs_lib_ctx_init(core)\");\n", "        if (pio->core == NULL) {\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        memset(pio->core, 0, sizeof(*pio->core));\n", "        pio->core->globals = globals;\n", "        pio->core->fs = (gs_fs_list_t *)gs_alloc_bytes_immovable(mem,\n                                                                 sizeof(gs_fs_list_t),\n                                                                 \"gs_lib_ctx_init(gs_fs_list_t)\");\n", "        if (pio->core->fs == NULL) {\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->cal_ctx = cal_init(&cal_allocs, mem);\n", "        if (pio->core->cal_ctx == NULL) {\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->fs->fs.open_file = fs_file_open_file;\n", "        pio->core->fs->fs.open_pipe = NULL;\n", "        pio->core->fs->fs.open_scratch = fs_file_open_scratch;\n", "        pio->core->fs->fs.open_printer = fs_file_open_printer;\n", "        pio->core->fs->secret = NULL;\n", "        pio->core->fs->memory = mem;\n", "        pio->core->fs->next   = NULL;\n", "        pio->core->monitor = gx_monitor_alloc(mem);\n", "        if (pio->core->monitor == NULL)\n", "        pio->core->refs = 1;\n", "        pio->core->memory = mem;\n", "        gs_lib_ctx_get_real_stdio(&pio->core->fstdin, &pio->core->fstdout, &pio->core->fstderr );\n", "        pio->core->stdin_is_interactive = true;\n", "        pio->core->gs_next_id = 5; /* Cloned contexts share the state */\n", "        pio->core->scanconverter = GS_SCANCONVERTER_DEFAULT;\n", "        pio->core->cms_context = gscms_create(mem);\n", "        if (pio->core->cms_context == NULL) {\n", "            gx_monitor_free((gx_monitor_t *)(pio->core->monitor));\n", "            cal_fin(pio->core->cal_ctx, mem);\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "    pio->memory               = mem;\n", "    mem->gs_lib_ctx = pio;\n", "    pio->profiledir = NULL;\n", "    pio->profiledir_len = 0;\n", "    pio->icc_color_accuracy = MAX_COLOR_ACCURACY;\n", "    if (gs_lib_ctx_set_icc_directory(mem, DEFAULT_DIR_ICC, strlen(DEFAULT_DIR_ICC)) < 0)\n", "    if (gs_lib_ctx_set_default_device_list(mem, gs_dev_defaults,\n                                           strlen(gs_dev_defaults)) < 0)\n", "    if (sjpxd_create(mem))\n", "    pio->client_check_file_permission = NULL;\n", "    gp_get_realtime(pio->real_time_0);\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->name_table_root))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->io_device_table_root))\n"], "tokenized": "int FUNC1(STRUCT1 *Var1,STRUCT2 *Var2)\nSTRUCT1 *Var3=NULL ; \nSTRUCT3 *Var4; \nif (Var2->memberVar1)/*Var5  STRUCT4 STRUCT5 */\nVar3=(STRUCT1 *) FUNC2(Var2,\nsizeof (STRUCT1),\nSTRING); \nif (Var3 == NULL )\nmemset(Var3,0,sizeof (*Var3)); \nif (Var1 != NULL ){\nVar3->memberVar1=Var1->memberVar1; \nFUNC3((STRUCT6 *)(Var3->memberVar1->memberVar1)); \nVar3->memberVar1->STRUCT7  Var6; \nFUNC4((STRUCT6 *)(Var3->memberVar1->memberVar1)); \nelse \nVar3->memberVar1=(STRUCT8 *) FUNC2(Var2,\nsizeof (STRUCT8),\nSTRING); \nif (Var3->memberVar1 == NULL ){\nFUNC5(Var2,Var3,STRING); \nmemset(Var3->memberVar1,0,sizeof (*Var3->memberVar1)); \nVar3->memberVar1->memberVar2=memberVar2; \nVar3->memberVar1->memberVar3=(STRUCT9 *) FUNC2(Var2,\nsizeof (STRUCT9),\nSTRING); \nif (Var3->memberVar1->memberVar3 == NULL ){\nFUNC5(Var2,Var3->memberVar1,STRING); \nFUNC5(Var2,Var3,STRING); \nVar3->memberVar1->memberVar4=FUNC6(&Var7,Var2); \nif (Var3->memberVar1->memberVar4 == NULL ){\nFUNC5(Var2,Var3->memberVar1->memberVar3,STRING); \nFUNC5(Var2,Var3->memberVar1,STRING); \nFUNC5(Var2,Var3,STRING); \nVar3->memberVar1->memberVar3->memberVar1.memberVar2=Var8; \nVar3->memberVar1->memberVar3->memberVar1.memberVar3=NULL ; \nVar3->memberVar1->memberVar3->memberVar1.memberVar4=Var9; \nVar3->memberVar1->memberVar3->memberVar1.memberVar5=Var10; \nVar3->memberVar1->memberVar3->memberVar6=NULL ; \nVar3->memberVar1->memberVar3->memberVar7=Var2; \nVar3->memberVar1->memberVar3->memberVar8=NULL ; \nVar3->memberVar1->memberVar1=FUNC7(Var2); \nif (Var3->memberVar1->memberVar1 == NULL )\nVar3->memberVar1->memberVar5=1; \nVar3->memberVar1->memberVar6=Var2; \nFUNC8(&Var3->memberVar1->memberVar7,&Var3->memberVar1->memberVar8,&Var3->memberVar1->memberVar9); \nVar3->memberVar1->memberVar10=true ; \nVar3->memberVar1->memberVar11=5; /*Var11  Var12  Var13  STRUCT10 STRUCT11 */\nVar3->memberVar1->memberVar12=Var14; \nVar3->memberVar1->memberVar13=FUNC9(Var2); \nif (Var3->memberVar1->memberVar13 == NULL ){\nFUNC10((STRUCT6 *)(Var3->memberVar1->memberVar1)); \nFUNC11(Var3->memberVar1->memberVar4,Var2); \nFUNC5(Var2,Var3->memberVar1->memberVar3,STRING); \nFUNC5(Var2,Var3->memberVar1,STRING); \nFUNC5(Var2,Var3,STRING); \nVar3->memberVar2=Var2; \nVar2->memberVar1=Var3; \nVar3->memberVar3=NULL ; \nVar3->memberVar4=0; \nVar3->memberVar5=Var15; \nif (FUNC12(Var2,Var16,strlen(Var16))<0)\nif (FUNC13(Var2,Var17,\nstrlen(Var17))<0)\nif (FUNC14(Var2))\nVar3->memberVar6=NULL ; \nFUNC15(Var3->memberVar7); \nif (FUNC16(Var2,&Var3->memberVar8))\nif (FUNC16(Var2,&Var3->memberVar9))\n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_init", "Source": false, "Sink": false, "idx": 7, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 367, "label": -3, "slices": ["int gs_lib_ctx_init(gs_lib_ctx_t *ctx, gs_memory_t *mem)\n", "    gs_lib_ctx_t *pio = NULL;\n", "    gp_set_debug_mem_ptr(mem);\n", "    if (mem->gs_lib_ctx) /* one time initialization */\n", "    pio = (gs_lib_ctx_t*)gs_alloc_bytes_immovable(mem,\n                                                  sizeof(gs_lib_ctx_t),\n                                                  \"gs_lib_ctx_init\");\n", "    if(pio == NULL)\n", "    if (ctx != NULL) {\n", "else\n", "        pio->core = (gs_lib_ctx_core_t *)gs_alloc_bytes_immovable(mem,\n                                                                  sizeof(gs_lib_ctx_core_t),\n                                                                  \"gs_lib_ctx_init(core)\");\n", "        if (pio->core == NULL) {\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->fs = (gs_fs_list_t *)gs_alloc_bytes_immovable(mem,\n                                                                 sizeof(gs_fs_list_t),\n                                                                 \"gs_lib_ctx_init(gs_fs_list_t)\");\n", "        if (pio->core->fs == NULL) {\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->cal_ctx = cal_init(&cal_allocs, mem);\n", "        if (pio->core->cal_ctx == NULL) {\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->fs->memory = mem;\n", "        pio->core->monitor = gx_monitor_alloc(mem);\n", "        if (pio->core->monitor == NULL)\n", "        pio->core->memory = mem;\n", "        pio->core->cms_context = gscms_create(mem);\n", "        if (pio->core->cms_context == NULL) {\n", "            cal_fin(pio->core->cal_ctx, mem);\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "    pio->memory               = mem;\n", "    mem->gs_lib_ctx = pio;\n", "    if (gs_lib_ctx_set_icc_directory(mem, DEFAULT_DIR_ICC, strlen(DEFAULT_DIR_ICC)) < 0)\n", "    if (gs_lib_ctx_set_default_device_list(mem, gs_dev_defaults,\n                                           strlen(gs_dev_defaults)) < 0)\n", "    if (sjpxd_create(mem))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->name_table_root))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->io_device_table_root))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->font_dir_root))\n", "    if (gs_add_control_path(mem, gs_permit_file_writing, gp_null_file_name) < 0)\n", "    gs_lib_ctx_fin(mem);\n"], "tokenized": "int FUNC1(STRUCT1 *Var1,STRUCT2 *Var2)\nSTRUCT1 *Var3=NULL ; \nFUNC2(Var2); \nif (Var2->memberVar1)/*Var4  STRUCT3 STRUCT4 */\nVar3=(STRUCT1 *) FUNC3(Var2,\nsizeof (STRUCT1),\nSTRING); \nif (Var3 == NULL )\nif (Var1 != NULL ){\nelse \nVar3->memberVar1=(STRUCT5 *) FUNC3(Var2,\nsizeof (STRUCT5),\nSTRING); \nif (Var3->memberVar1 == NULL ){\nFUNC4(Var2,Var3,STRING); \nVar3->memberVar1->memberVar1=(STRUCT6 *) FUNC3(Var2,\nsizeof (STRUCT6),\nSTRING); \nif (Var3->memberVar1->memberVar1 == NULL ){\nFUNC4(Var2,Var3->memberVar1,STRING); \nFUNC4(Var2,Var3,STRING); \nVar3->memberVar1->memberVar2=FUNC5(&Var5,Var2); \nif (Var3->memberVar1->memberVar2 == NULL ){\nFUNC4(Var2,Var3->memberVar1->memberVar1,STRING); \nFUNC4(Var2,Var3->memberVar1,STRING); \nFUNC4(Var2,Var3,STRING); \nVar3->memberVar1->memberVar1->memberVar1=Var2; \nVar3->memberVar1->memberVar3=FUNC6(Var2); \nif (Var3->memberVar1->memberVar3 == NULL )\nVar3->memberVar1->memberVar4=Var2; \nVar3->memberVar1->memberVar5=FUNC7(Var2); \nif (Var3->memberVar1->memberVar5 == NULL ){\nFUNC8(Var3->memberVar1->memberVar2,Var2); \nFUNC4(Var2,Var3->memberVar1->memberVar1,STRING); \nFUNC4(Var2,Var3->memberVar1,STRING); \nFUNC4(Var2,Var3,STRING); \nVar3->memberVar2=Var2; \nVar2->memberVar1=Var3; \nif (FUNC9(Var2,Var6,strlen(Var6))<0)\nif (FUNC10(Var2,Var7,\nstrlen(Var7))<0)\nif (FUNC11(Var2))\nif (FUNC12(Var2,&Var3->memberVar3))\nif (FUNC12(Var2,&Var3->memberVar4))\nif (FUNC12(Var2,&Var3->memberVar5))\nif (FUNC13(Var2,Var8,Var9)<0)\nFUNC14(Var2); \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_init", "Source": false, "Sink": false, "idx": 8, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 370, "label": -3, "slices": ["int gs_lib_ctx_init(gs_lib_ctx_t *ctx, gs_memory_t *mem)\n", "    gs_lib_ctx_t *pio = NULL;\n", "    gp_set_debug_mem_ptr(mem);\n", "    if (mem->gs_lib_ctx) /* one time initialization */\n", "    pio = (gs_lib_ctx_t*)gs_alloc_bytes_immovable(mem,\n                                                  sizeof(gs_lib_ctx_t),\n                                                  \"gs_lib_ctx_init\");\n", "    if(pio == NULL)\n", "    if (ctx != NULL) {\n", "else\n", "        pio->core = (gs_lib_ctx_core_t *)gs_alloc_bytes_immovable(mem,\n                                                                  sizeof(gs_lib_ctx_core_t),\n                                                                  \"gs_lib_ctx_init(core)\");\n", "        if (pio->core == NULL) {\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->fs = (gs_fs_list_t *)gs_alloc_bytes_immovable(mem,\n                                                                 sizeof(gs_fs_list_t),\n                                                                 \"gs_lib_ctx_init(gs_fs_list_t)\");\n", "        if (pio->core->fs == NULL) {\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->cal_ctx = cal_init(&cal_allocs, mem);\n", "        if (pio->core->cal_ctx == NULL) {\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "        pio->core->fs->memory = mem;\n", "        pio->core->monitor = gx_monitor_alloc(mem);\n", "        if (pio->core->monitor == NULL)\n", "        pio->core->memory = mem;\n", "        pio->core->cms_context = gscms_create(mem);\n", "        if (pio->core->cms_context == NULL) {\n", "            cal_fin(pio->core->cal_ctx, mem);\n", "            gs_free_object(mem, pio->core->fs, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio->core, \"gs_lib_ctx_init\");\n", "            gs_free_object(mem, pio, \"gs_lib_ctx_init\");\n", "    pio->memory               = mem;\n", "    mem->gs_lib_ctx = pio;\n", "    if (gs_lib_ctx_set_icc_directory(mem, DEFAULT_DIR_ICC, strlen(DEFAULT_DIR_ICC)) < 0)\n", "    if (gs_lib_ctx_set_default_device_list(mem, gs_dev_defaults,\n                                           strlen(gs_dev_defaults)) < 0)\n", "    if (sjpxd_create(mem))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->name_table_root))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->io_device_table_root))\n", "    if (gs_lib_ctx_alloc_root_structure(mem, &pio->font_dir_root))\n", "    if (gs_add_control_path(mem, gs_permit_file_writing, gp_null_file_name) < 0)\n", "    gs_lib_ctx_fin(mem);\n"], "tokenized": "int FUNC1(STRUCT1 *Var1,STRUCT2 *Var2)\nSTRUCT1 *Var3=NULL ; \nFUNC2(Var2); \nif (Var2->memberVar1)/*Var4  STRUCT3 STRUCT4 */\nVar3=(STRUCT1 *) FUNC3(Var2,\nsizeof (STRUCT1),\nSTRING); \nif (Var3 == NULL )\nif (Var1 != NULL ){\nelse \nVar3->memberVar1=(STRUCT5 *) FUNC3(Var2,\nsizeof (STRUCT5),\nSTRING); \nif (Var3->memberVar1 == NULL ){\nFUNC4(Var2,Var3,STRING); \nVar3->memberVar1->memberVar1=(STRUCT6 *) FUNC3(Var2,\nsizeof (STRUCT6),\nSTRING); \nif (Var3->memberVar1->memberVar1 == NULL ){\nFUNC4(Var2,Var3->memberVar1,STRING); \nFUNC4(Var2,Var3,STRING); \nVar3->memberVar1->memberVar2=FUNC5(&Var5,Var2); \nif (Var3->memberVar1->memberVar2 == NULL ){\nFUNC4(Var2,Var3->memberVar1->memberVar1,STRING); \nFUNC4(Var2,Var3->memberVar1,STRING); \nFUNC4(Var2,Var3,STRING); \nVar3->memberVar1->memberVar1->memberVar1=Var2; \nVar3->memberVar1->memberVar3=FUNC6(Var2); \nif (Var3->memberVar1->memberVar3 == NULL )\nVar3->memberVar1->memberVar4=Var2; \nVar3->memberVar1->memberVar5=FUNC7(Var2); \nif (Var3->memberVar1->memberVar5 == NULL ){\nFUNC8(Var3->memberVar1->memberVar2,Var2); \nFUNC4(Var2,Var3->memberVar1->memberVar1,STRING); \nFUNC4(Var2,Var3->memberVar1,STRING); \nFUNC4(Var2,Var3,STRING); \nVar3->memberVar2=Var2; \nVar2->memberVar1=Var3; \nif (FUNC9(Var2,Var6,strlen(Var6))<0)\nif (FUNC10(Var2,Var7,\nstrlen(Var7))<0)\nif (FUNC11(Var2))\nif (FUNC12(Var2,&Var3->memberVar3))\nif (FUNC12(Var2,&Var3->memberVar4))\nif (FUNC12(Var2,&Var3->memberVar5))\nif (FUNC13(Var2,Var8,Var9)<0)\nFUNC14(Var2); \n"}, {"FileName": "before.c", "Caller": "outwrite", "Source": false, "Sink": false, "idx": 9, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fwrite", "line": 516, "label": -3, "slices": ["int outwrite(const gs_memory_t *mem, const char *str, int len)\n", "    int code;\n", "    gs_lib_ctx_t *pio = mem->gs_lib_ctx;\n", "    gs_lib_ctx_core_t *core = pio->core;\n", "    if (len == 0)\n", "    if (core->stdout_is_redirected) {\n", "        if (core->stdout_to_stderr)\n", "            return errwrite(mem, str, len);\n", "        code = gp_fwrite(str, 1, len, core->fstdout2);\n", "else\n", "    } else if (core->stdout_fn) {\n", "        return (*core->stdout_fn)(core->std_caller_handle, str, len);\n", "else\n", "        code = fwrite(str, 1, len, core->fstdout);\n", "        fflush(core->fstdout);\n", "    return code;\n"], "tokenized": "int FUNC1(const STRUCT1 *Var1,const char *Var2,int  Var3)\nint  Var4; \nSTRUCT2 *Var5=Var1->memberVar1; \nSTRUCT3 *Var6=Var5->memberVar1; \nif (Var3 == 0)\nif (memberVar1->memberVar1){\nif (memberVar1->memberVar2)\nreturn FUNC2(Var1,Var2,Var3); \nVar4=FUNC3(Var2,1,Var3,memberVar1->memberVar3); \nelse \n}else if (memberVar1->memberVar4){\nreturn (*memberVar1->memberVar4)(memberVar1->memberVar5,Var2,Var3); \nelse \nVar4=fwrite(Var2,1,Var3,memberVar1->memberVar6); \nFUNC4(memberVar1->memberVar6); \nreturn  Var4; \n"}, {"FileName": "before.c", "Caller": "errwrite", "Source": false, "Sink": false, "idx": 10, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fwrite", "line": 543, "label": -3, "slices": ["int errwrite(const gs_memory_t *mem, const char *str, int len)\n", "    int code;\n", "    gs_lib_ctx_t *ctx;\n", "    gs_lib_ctx_core_t *core;\n", "    if (len == 0)\n", "    if (mem == NULL) {\n", "        mem = gp_get_debug_mem_ptr();\n", "        if (mem == NULL)\n", "    ctx = mem->gs_lib_ctx;\n", "    if (ctx == NULL)\n", "    core = ctx->core;\n", "    if (core->stderr_fn)\n", "        return (*core->stderr_fn)(core->std_caller_handle, str, len);\n", "    code = fwrite(str, 1, len, core->fstderr);\n", "    fflush(core->fstderr);\n", "    return code;\n"], "tokenized": "int FUNC1(const STRUCT1 *Var1,const char *Var2,int  Var3)\nint  Var4; \nSTRUCT2 *Var5; \nSTRUCT3 *Var6; \nif (Var3 == 0)\nif (Var1 == NULL ){\nVar1=FUNC2(); \nif (Var1 == NULL )\nVar5=Var1->memberVar1; \nif (Var5 == NULL )\nVar6=Var5->memberVar1; \nif (memberVar1->memberVar1)\nreturn (*memberVar1->memberVar1)(memberVar1->memberVar2,Var2,Var3); \nVar4=fwrite(Var2,1,Var3,memberVar1->memberVar3); \nFUNC3(memberVar1->memberVar3); \nreturn  Var4; \n"}, {"FileName": "before.c", "Caller": "rewrite_percent_specifiers", "Source": false, "Sink": false, "idx": 11, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 631, "label": -3, "slices": ["rewrite_percent_specifiers(char *s)\n", "    char *match_start;\n", "    while (*s)\n", "        int flags;\n", "        while (*s && *s != '%')\n", "            s++;\n", "        if (*s == 0)\n", "        match_start = s;\n", "        s++;\n", "        while (*s) {\n", "            if (*s == '-' && (flags & 1) == 0)\n", "else\n", "            else if (*s == '+' && (flags & 2) == 0)\n", "else\n", "            else if (*s == ' ' && (flags & 4) == 0)\n", "else\n", "            else if (*s == '0' && (flags & 8) == 0)\n", "else\n", "            else if (*s == '#' && (flags & 16) == 0)\n", "            s++;\n", "        while (*s >= '0' && *s <= '9')\n", "            s++;\n", "        if (*s == '.' && s[1] >= '0' && s[1] <= '9') {\n", "            s++;\n", "            while (*s >= '0' && *s <= '9')\n", "                s++;\n", "        if (*s == 'l')\n", "            s++;\n", "        if (*s == 'd' ||\n            *s == 'i' ||\n            *s == 'u' ||\n            *s == 'o' ||\n            *s == 'x' ||\n            *s == 'X') {\n", "            memset(match_start, '*', s - match_start + 1);\n", "else\n", "        else if (*s == '%') {\n", "            char *s0 = s;\n"], "tokenized": "FUNC1(char *Var1)\nchar *Var2; \nwhile (*Var1)\nint  Var3; \nwhile (*Var1&&*Var1 != %)\nVar1  Var4; \nif (*Var1 == 0)\nVar2=Var1; \nVar1  Var4; \nwhile (*Var1){\nif (*Var1 == -&&(Var3&1) == 0)\nelse \nelse if (*Var1 == +&&(Var3&2) == 0)\nelse \nelse if (*Var1 == &&(Var3&4) == 0)\nelse \nelse if (*Var1 == 0&&(Var3&8) == 0)\nelse \nelse if (*Var1 == &&(Var3&16) == 0)\nVar1  Var4; \nwhile (*Var1 >= 0&&*Var1 <= 9)\nVar1  Var4; \nif (*Var1 == .&&Var1[1]>= 0&&Var1[1]<= 9){\nVar1  Var4; \nwhile (*Var1 >= 0&&*Var1 <= 9)\nVar1  Var4; \nif (*Var1 ==  Var5)\nVar1  Var4; \nif (*Var1 ==  Var6||\n*Var1 ==  Var7||\n*Var1 ==  Var8||\n*Var1 ==  Var9||\n*Var1 ==  Var10||\n*Var1 ==  Var11){\nmemset(Var2,*,Var1-Var2+1); \nelse \nelse if (*Var1 == %){\nchar *Var12=Var1; \n"}, {"FileName": "before.c", "Caller": "gs_add_outputfile_control_path", "Source": false, "Sink": false, "idx": 12, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 662, "label": -3, "slices": ["gs_add_outputfile_control_path(gs_memory_t *mem, const char *fname)\n", "    char f[gp_file_name_sizeof];\n", "    if (strlen(fname) >= gp_file_name_sizeof)\n", "    strcpy(f, fname);\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nchar  Var3[Var4]; \nif (strlen(Var2) >=  Var4)\nstrcpy(Var3,Var2); \n"}, {"FileName": "before.c", "Caller": "gs_add_outputfile_control_path", "Source": false, "Sink": false, "idx": 13, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 664, "label": -3, "slices": ["gs_add_outputfile_control_path(gs_memory_t *mem, const char *fname)\n", "    char f[gp_file_name_sizeof];\n", "    int code;\n", "    if (strlen(fname) >= gp_file_name_sizeof)\n", "    strcpy(f, fname);\n", "    rewrite_percent_specifiers(f);\n", "    code = gs_add_control_path(mem, gs_permit_file_control, f);\n", "    if (code < 0)\n", "    return gs_add_control_path(mem, gs_permit_file_writing, f);\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nchar  Var3[Var4]; \nint  Var5; \nif (strlen(Var2) >=  Var4)\nstrcpy(Var3,Var2); \nFUNC2(Var3); \nVar5=FUNC3(Var1,Var6,Var3); \nif (Var5<0)\nreturn FUNC3(Var1,Var7,Var3); \n"}, {"FileName": "before.c", "Caller": "gs_remove_outputfile_control_path", "Source": false, "Sink": false, "idx": 14, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 681, "label": -3, "slices": ["gs_remove_outputfile_control_path(gs_memory_t *mem, const char *fname)\n", "    char f[gp_file_name_sizeof];\n", "    if (strlen(fname) >= gp_file_name_sizeof)\n", "    strcpy(f, fname);\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nchar  Var3[Var4]; \nif (strlen(Var2) >=  Var4)\nstrcpy(Var3,Var2); \n"}, {"FileName": "before.c", "Caller": "gs_remove_outputfile_control_path", "Source": false, "Sink": false, "idx": 15, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 683, "label": -3, "slices": ["gs_remove_outputfile_control_path(gs_memory_t *mem, const char *fname)\n", "    char f[gp_file_name_sizeof];\n", "    int code;\n", "    if (strlen(fname) >= gp_file_name_sizeof)\n", "    strcpy(f, fname);\n", "    rewrite_percent_specifiers(f);\n", "    code = gs_remove_control_path(mem, gs_permit_file_control, f);\n", "    if (code < 0)\n", "    return gs_remove_control_path(mem, gs_permit_file_writing, f);\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nchar  Var3[Var4]; \nint  Var5; \nif (strlen(Var2) >=  Var4)\nstrcpy(Var3,Var2); \nFUNC2(Var3); \nVar5=FUNC3(Var1,Var6,Var3); \nif (Var5<0)\nreturn FUNC3(Var1,Var7,Var3); \n"}, {"FileName": "before.c", "Caller": "gs_add_explicit_control_path", "Source": false, "Sink": false, "idx": 16, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 702, "label": -3, "slices": ["gs_add_explicit_control_path(gs_memory_t *mem, const char *arg, gs_path_control_t control)\n", "    char *p2, *p1 = (char *)arg;\n", "    const char *lim;\n", "    int code = 0;\n", "    if (arg == NULL)\n", "    lim = arg + strlen(arg);\n", "    while (code >= 0 && p1 < lim && (p2 = strchr(p1, (int)gp_file_name_list_separator)) != NULL) {\n", "        code = gs_add_control_path_len(mem, control, p1, (int)(p2 - p1));\n", "        p1 = p2 + 1;\n", "    if (p1 < lim)\n", "        code = gs_add_control_path_len(mem, control, p1, (int)(lim - p1));\n", "    return code;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2,STRUCT2  Var3)\nchar *Var4,*Var5=(char *) Var2; \nconst char *Var6; \nint  Var7=0; \nif (Var2 == NULL )\nVar6=Var2+strlen(Var2); \nwhile (Var7 >= 0&&Var5<Var6&&(Var4=strchr(Var5,(int ) Var8)) != NULL ){\nVar7=FUNC2(Var1,Var3,Var5,(int )(Var4-Var5)); \nVar5=Var4+1; \nif (Var5<Var6)\nVar7=FUNC2(Var1,Var3,Var5,(int )(Var6-Var5)); \nreturn  Var7; \n"}, {"FileName": "before.c", "Caller": "gs_add_explicit_control_path", "Source": false, "Sink": false, "idx": 17, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 703, "label": -3, "slices": ["gs_add_explicit_control_path(gs_memory_t *mem, const char *arg, gs_path_control_t control)\n", "    char *p2, *p1 = (char *)arg;\n", "    const char *lim;\n", "    int code = 0;\n", "    if (arg == NULL)\n", "    lim = arg + strlen(arg);\n", "    while (code >= 0 && p1 < lim && (p2 = strchr(p1, (int)gp_file_name_list_separator)) != NULL) {\n", "        code = gs_add_control_path_len(mem, control, p1, (int)(p2 - p1));\n", "        p1 = p2 + 1;\n", "    if (p1 < lim)\n", "        code = gs_add_control_path_len(mem, control, p1, (int)(lim - p1));\n", "    return code;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2,STRUCT2  Var3)\nchar *Var4,*Var5=(char *) Var2; \nconst char *Var6; \nint  Var7=0; \nif (Var2 == NULL )\nVar6=Var2+strlen(Var2); \nwhile (Var7 >= 0&&Var5<Var6&&(Var4=strchr(Var5,(int ) Var8)) != NULL ){\nVar7=FUNC2(Var1,Var3,Var5,(int )(Var4-Var5)); \nVar5=Var4+1; \nif (Var5<Var6)\nVar7=FUNC2(Var1,Var3,Var5,(int )(Var6-Var5)); \nreturn  Var7; \n"}, {"FileName": "before.c", "Caller": "gs_add_control_path_len_flags", "Source": false, "Sink": false, "idx": 18, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcmp", "line": 751, "label": -3, "slices": ["gs_add_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)\n", "    gs_path_control_set_t *control;\n", "    unsigned int n, i;\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen;\n", "    if (path == NULL || len == 0)\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    switch(type) {\n", "    if (path[0] == '|' || (len > 5 && memcmp(path, \"%pipe\", 5) == 0)) {\n", "        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, \"gs_add_control_path_len\");\n", "        if (buffer == NULL)\n", "        memcpy(buffer, path, len);\n", "        buffer[len] = 0;\n", "        rlen = len;\n", "else\n", "        rlen = len + 1;\n", "        if (buffer == NULL)\n", "        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)\n", "    for (i = 0; i < n; i++)\n", "        if (strncmp(control->entry[i].path, buffer, rlen) == 0 &&\n            control->entry[i].path[rlen] == 0) {\n", "    if (control->num == control->max) {\n", "        gs_path_control_entry_t *p;\n", "        if (p == NULL) {\n", "    control->entry[n].path[len] = 0;\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3,size_t  Var4,int  Var5)\nSTRUCT3 *Var6; \nunsigned int  Var7,Var8; \nSTRUCT4 *Var9; \nchar *Var10; \nuint  Var11; \nif (Var3 == NULL ||Var4 == 0)\nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var9=Var1->memberVar1->memberVar1) == NULL )\nswitch (Var2){\nif (Var3[0]== |||(Var4>5&&memcmp(Var3,STRING,5) == 0)){\nVar10=(char *) FUNC2(memberVar1->memberVar1,Var4+1,STRING); \nif (Var10 == NULL )\nmemcpy(Var10,Var3,Var4); \nVar10[Var4]=0; \nVar11=Var4; \nelse \nVar11=Var4+1; \nif (Var10 == NULL )\nif (FUNC3(Var3,(uint ) Var4,Var10,&Var11) !=  Var12)\nfor (Var8=0; Var8<Var7; Var8  Var13)\nif (FUNC4(Var6->memberVar1[Var8].memberVar1,Var10,Var11) == 0&&\nVar6->memberVar1[Var8].memberVar1[Var11]== 0){\nif (Var6->memberVar2 ==  Var6->memberVar3){\nSTRUCT5 *Var14; \nif (Var14 == NULL ){\nVar6->memberVar1[Var7].memberVar1[Var4]=0; \n"}, {"FileName": "before.c", "Caller": "gs_add_control_path_len_flags", "Source": false, "Sink": false, "idx": 19, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 755, "label": -3, "slices": ["gs_add_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)\n", "    gs_path_control_set_t *control;\n", "    unsigned int n, i;\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen;\n", "    if (path == NULL || len == 0)\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    switch(type) {\n", "    if (path[0] == '|' || (len > 5 && memcmp(path, \"%pipe\", 5) == 0)) {\n", "        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, \"gs_add_control_path_len\");\n", "        if (buffer == NULL)\n", "        memcpy(buffer, path, len);\n", "        buffer[len] = 0;\n", "        rlen = len;\n", "else\n", "        rlen = len + 1;\n", "        if (buffer == NULL)\n", "        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)\n", "    for (i = 0; i < n; i++)\n", "        if (strncmp(control->entry[i].path, buffer, rlen) == 0 &&\n            control->entry[i].path[rlen] == 0) {\n", "            gs_free_object(core->memory, buffer, \"gs_add_control_path_len\");\n", "    if (control->num == control->max) {\n", "        gs_path_control_entry_t *p;\n", "        if (p == NULL) {\n", "            gs_free_object(core->memory, buffer, \"gs_add_control_path_len\");\n", "    control->entry[n].path = buffer;\n", "    control->entry[n].path[len] = 0;\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3,size_t  Var4,int  Var5)\nSTRUCT3 *Var6; \nunsigned int  Var7,Var8; \nSTRUCT4 *Var9; \nchar *Var10; \nuint  Var11; \nif (Var3 == NULL ||Var4 == 0)\nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var9=Var1->memberVar1->memberVar1) == NULL )\nswitch (Var2){\nif (Var3[0]== |||(Var4>5&&memcmp(Var3,STRING,5) == 0)){\nVar10=(char *) FUNC2(memberVar1->memberVar1,Var4+1,STRING); \nif (Var10 == NULL )\nmemcpy(Var10,Var3,Var4); \nVar10[Var4]=0; \nVar11=Var4; \nelse \nVar11=Var4+1; \nif (Var10 == NULL )\nif (FUNC3(Var3,(uint ) Var4,Var10,&Var11) !=  Var12)\nfor (Var8=0; Var8<Var7; Var8  Var13)\nif (FUNC4(Var6->memberVar1[Var8].memberVar1,Var10,Var11) == 0&&\nVar6->memberVar1[Var8].memberVar1[Var11]== 0){\nFUNC5(memberVar1->memberVar1,Var10,STRING); \nif (Var6->memberVar2 ==  Var6->memberVar3){\nSTRUCT5 *Var14; \nif (Var14 == NULL ){\nFUNC5(memberVar1->memberVar1,Var10,STRING); \nVar6->memberVar1[Var7].memberVar1=Var10; \nVar6->memberVar1[Var7].memberVar1[Var4]=0; \n"}, {"FileName": "before.c", "Caller": "gs_add_control_path", "Source": false, "Sink": false, "idx": 20, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 810, "label": -3, "slices": ["gs_add_control_path(const gs_memory_t *mem, gs_path_control_t type, const char *path)\n", "    return gs_add_control_path_len_flags(mem, type, path, path ? strlen(path) : 0, 0);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3)\nreturn FUNC2(Var1,Var2,Var3,Var3 strlen(Var3) 0,0); \n"}, {"FileName": "before.c", "Caller": "gs_add_control_path_flags", "Source": false, "Sink": false, "idx": 21, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 816, "label": -3, "slices": ["gs_add_control_path_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, int flags)\n", "    return gs_add_control_path_len_flags(mem, type, path, path ? strlen(path) : 0, flags);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3,int  Var4)\nreturn FUNC2(Var1,Var2,Var3,Var3 strlen(Var3) 0,Var4); \n"}, {"FileName": "before.c", "Caller": "gs_remove_control_path_len_flags", "Source": false, "Sink": false, "idx": 22, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcmp", "line": 858, "label": -3, "slices": ["gs_remove_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)\n", "    gs_path_control_set_t *control;\n", "    unsigned int n, i;\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen;\n", "    if (path == NULL || len == 0)\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    switch(type) {\n", "    if (path[0] == '|' || (len > 5 && memcmp(path, \"%pipe\", 5) == 0)) {\n", "        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, \"gs_remove_control_path_len\");\n", "        if (buffer == NULL)\n", "        memcpy(buffer, path, len);\n", "        buffer[len] = 0;\n", "        rlen = len;\n", "else\n", "        rlen = len+1;\n", "        if (buffer == NULL)\n", "        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)\n", "    for (i = 0; i < n; i++) {\n", "        if (control->entry[i].flags == flags &&\n            strncmp(control->entry[i].path, buffer, len) == 0 &&\n            control->entry[i].path[len] == 0)\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3,size_t  Var4,int  Var5)\nSTRUCT3 *Var6; \nunsigned int  Var7,Var8; \nSTRUCT4 *Var9; \nchar *Var10; \nuint  Var11; \nif (Var3 == NULL ||Var4 == 0)\nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var9=Var1->memberVar1->memberVar1) == NULL )\nswitch (Var2){\nif (Var3[0]== |||(Var4>5&&memcmp(Var3,STRING,5) == 0)){\nVar10=(char *) FUNC2(memberVar1->memberVar1,Var4+1,STRING); \nif (Var10 == NULL )\nmemcpy(Var10,Var3,Var4); \nVar10[Var4]=0; \nVar11=Var4; \nelse \nVar11=Var4+1; \nif (Var10 == NULL )\nif (FUNC3(Var3,(uint ) Var4,Var10,&Var11) !=  Var12)\nfor (Var8=0; Var8<Var7; Var8  Var13){\nif (Var6->memberVar1[Var8].memberVar1 ==  memberVar1&&\nFUNC4(Var6->memberVar1[Var8].memberVar2,Var10,Var4) == 0&&\nVar6->memberVar1[Var8].memberVar2[Var4]== 0)\n"}, {"FileName": "before.c", "Caller": "gs_remove_control_path_len_flags", "Source": false, "Sink": false, "idx": 23, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 862, "label": -3, "slices": ["gs_remove_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)\n", "    gs_path_control_set_t *control;\n", "    unsigned int n, i;\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen;\n", "    if (path == NULL || len == 0)\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    switch(type) {\n", "    if (path[0] == '|' || (len > 5 && memcmp(path, \"%pipe\", 5) == 0)) {\n", "        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, \"gs_remove_control_path_len\");\n", "        if (buffer == NULL)\n", "        memcpy(buffer, path, len);\n", "        buffer[len] = 0;\n", "        rlen = len;\n", "else\n", "        rlen = len+1;\n", "        if (buffer == NULL)\n", "        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)\n", "    for (i = 0; i < n; i++) {\n", "        if (control->entry[i].flags == flags &&\n            strncmp(control->entry[i].path, buffer, len) == 0 &&\n            control->entry[i].path[len] == 0)\n", "    gs_free_object(core->memory, buffer, \"gs_remove_control_path_len\");\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3,size_t  Var4,int  Var5)\nSTRUCT3 *Var6; \nunsigned int  Var7,Var8; \nSTRUCT4 *Var9; \nchar *Var10; \nuint  Var11; \nif (Var3 == NULL ||Var4 == 0)\nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var9=Var1->memberVar1->memberVar1) == NULL )\nswitch (Var2){\nif (Var3[0]== |||(Var4>5&&memcmp(Var3,STRING,5) == 0)){\nVar10=(char *) FUNC2(memberVar1->memberVar1,Var4+1,STRING); \nif (Var10 == NULL )\nmemcpy(Var10,Var3,Var4); \nVar10[Var4]=0; \nVar11=Var4; \nelse \nVar11=Var4+1; \nif (Var10 == NULL )\nif (FUNC3(Var3,(uint ) Var4,Var10,&Var11) !=  Var12)\nfor (Var8=0; Var8<Var7; Var8  Var13){\nif (Var6->memberVar1[Var8].memberVar1 ==  memberVar1&&\nFUNC4(Var6->memberVar1[Var8].memberVar2,Var10,Var4) == 0&&\nVar6->memberVar1[Var8].memberVar2[Var4]== 0)\nFUNC5(memberVar1->memberVar1,Var10,STRING); \n"}, {"FileName": "before.c", "Caller": "gs_remove_control_path", "Source": false, "Sink": false, "idx": 24, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 903, "label": -3, "slices": ["gs_remove_control_path(const gs_memory_t *mem, gs_path_control_t type, const char *path)\n", "    if (path == NULL)\n", "    return gs_remove_control_path_len_flags(mem, type, path, strlen(path), 0);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3)\nif (Var3 == NULL )\nreturn FUNC2(Var1,Var2,Var3,strlen(Var3),0); \n"}, {"FileName": "before.c", "Caller": "gs_remove_control_path_flags", "Source": false, "Sink": false, "idx": 25, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 912, "label": -3, "slices": ["gs_remove_control_path_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, int flags)\n", "    if (path == NULL)\n", "    return gs_remove_control_path_len_flags(mem, type, path, strlen(path), flags);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,STRUCT2  Var2,const char *Var3,int  Var4)\nif (Var3 == NULL )\nreturn FUNC2(Var1,Var2,Var3,strlen(Var3),Var4); \n"}, {"FileName": "before.c", "Caller": "gs_add_device_control", "Source": false, "Sink": false, "idx": 26, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 1101, "label": -3, "slices": ["static int gs_add_device_control(gs_memory_t *mem, char *device, int len)\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen, n, i;\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    rlen = len + 1;\n", "    buffer = (char *)gs_alloc_bytes(core->memory, rlen, \"gs_add_device\");\n", "    if (buffer == NULL)\n", "    memcpy(buffer, device, len);\n", "    buffer[len] = 0;\n", "    for (i = 0; i < n; i++)\n", "        if (strlen(core->permitted_devices.devices[i]) == len && strncmp(core->permitted_devices.devices[i], buffer, len) == 0) {\n", "            gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "    if (core->permitted_devices.num == core->permitted_devices.max) {\n", "        char **table;\n", "        if (n == 0) {\n", "            if (table == NULL) {\n", "                gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "            if (table == NULL) {\n", "                gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "    core->permitted_devices.devices[n] = buffer;\n"], "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,int  Var3)\nSTRUCT2 *Var4; \nchar *Var5; \nuint  Var6,Var7,Var8; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var4=Var1->memberVar1->memberVar1) == NULL )\nVar6=Var3+1; \nVar5=(char *) FUNC2(memberVar1->memberVar1,Var6,STRING); \nif (Var5 == NULL )\nmemcpy(Var5,Var2,Var3); \nVar5[Var3]=0; \nfor (Var8=0; Var8<Var7; Var8  Var9)\nif (strlen(memberVar1->memberVar2.memberVar1[Var8]) ==  Var3&&FUNC3(memberVar1->memberVar2.memberVar1[Var8],Var5,Var3) == 0){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nif (memberVar1->memberVar2.memberVar2 ==  memberVar1->memberVar2.memberVar3){\nchar **Var10; \nif (Var7 == 0){\nif (Var10 == NULL ){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nif (Var10 == NULL ){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nmemberVar1->memberVar2.memberVar1[Var7]=Var5; \n"}, {"FileName": "before.c", "Caller": "gs_add_device_control", "Source": false, "Sink": false, "idx": 27, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1107, "label": -3, "slices": ["static int gs_add_device_control(gs_memory_t *mem, char *device, int len)\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen, n, i;\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    rlen = len + 1;\n", "    buffer = (char *)gs_alloc_bytes(core->memory, rlen, \"gs_add_device\");\n", "    if (buffer == NULL)\n", "    memcpy(buffer, device, len);\n", "    buffer[len] = 0;\n", "    n = core->permitted_devices.num;\n", "    for (i = 0; i < n; i++)\n", "        if (strlen(core->permitted_devices.devices[i]) == len && strncmp(core->permitted_devices.devices[i], buffer, len) == 0) {\n", "            gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "    if (core->permitted_devices.num == core->permitted_devices.max) {\n", "        char **table;\n", "        n = core->permitted_devices.max * 2;\n", "        if (n == 0) {\n", "            table = (char **)gs_alloc_bytes(core->memory, sizeof(char *) * n, \"gs_add_device_control\");\n", "            if (table == NULL) {\n", "                gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "else\n", "            table = (char **)gs_resize_object(core->memory, core->permitted_devices.devices,sizeof(char *) * n, \"gs_add_device_control\");\n", "            if (table == NULL) {\n", "                gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "            memset(table + core->permitted_devices.max, 0x00, core->permitted_devices.max * sizeof(char *));\n", "        core->permitted_devices.devices = table;\n", "        core->permitted_devices.max = n;\n", "    n = core->permitted_devices.num;\n", "    core->permitted_devices.devices[n] = buffer;\n", "    core->permitted_devices.num++;\n"], "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,int  Var3)\nSTRUCT2 *Var4; \nchar *Var5; \nuint  Var6,Var7,Var8; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var4=Var1->memberVar1->memberVar1) == NULL )\nVar6=Var3+1; \nVar5=(char *) FUNC2(memberVar1->memberVar1,Var6,STRING); \nif (Var5 == NULL )\nmemcpy(Var5,Var2,Var3); \nVar5[Var3]=0; \nVar7=memberVar1->memberVar2.memberVar1; \nfor (Var8=0; Var8<Var7; Var8  Var9)\nif (strlen(memberVar1->memberVar2.memberVar2[Var8]) ==  Var3&&FUNC3(memberVar1->memberVar2.memberVar2[Var8],Var5,Var3) == 0){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nif (memberVar1->memberVar2.memberVar1 ==  memberVar1->memberVar2.memberVar3){\nchar **Var10; \nVar7=memberVar1->memberVar2.memberVar3 *2; \nif (Var7 == 0){\nVar10=(char **) FUNC2(memberVar1->memberVar1,sizeof (char *)*Var7,STRING); \nif (Var10 == NULL ){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nelse \nVar10=(char **) FUNC5(memberVar1->memberVar1,memberVar1->memberVar2.memberVar2,sizeof (char *)*Var7,STRING); \nif (Var10 == NULL ){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nmemset(Var10+memberVar1->memberVar2.memberVar3,0,memberVar1->memberVar2.memberVar3 *sizeof (char *)); \nmemberVar1->memberVar2.memberVar2=Var10; \nmemberVar1->memberVar2.memberVar3=Var7; \nVar7=memberVar1->memberVar2.memberVar1; \nmemberVar1->memberVar2.memberVar2[Var7]=Var5; \nmemberVar1->memberVar2.memberVar1  Var9; \n"}, {"FileName": "before.c", "Caller": "gs_add_device_control", "Source": false, "Sink": false, "idx": 28, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1124, "label": -3, "slices": ["static int gs_add_device_control(gs_memory_t *mem, char *device, int len)\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen, n, i;\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    if (buffer == NULL)\n", "    for (i = 0; i < n; i++)\n", "        if (strlen(core->permitted_devices.devices[i]) == len && strncmp(core->permitted_devices.devices[i], buffer, len) == 0) {\n", "    if (core->permitted_devices.num == core->permitted_devices.max) {\n", "        char **table;\n", "        if (n == 0) {\n", "            n = 2;\n", "            table = (char **)gs_alloc_bytes(core->memory, sizeof(char *) * n, \"gs_add_device_control\");\n", "            memset(table, 0x00, sizeof(char *) * n);\n", "        core->permitted_devices.devices = table;\n", "        core->permitted_devices.max = n;\n"], "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,int  Var3)\nSTRUCT2 *Var4; \nchar *Var5; \nuint  Var6,Var7,Var8; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var4=Var1->memberVar1->memberVar1) == NULL )\nif (Var5 == NULL )\nfor (Var8=0; Var8<Var7; Var8  Var9)\nif (strlen(memberVar1->memberVar1.memberVar1[Var8]) ==  Var3&&FUNC2(memberVar1->memberVar1.memberVar1[Var8],Var5,Var3) == 0){\nif (memberVar1->memberVar1.memberVar2 ==  memberVar1->memberVar1.memberVar3){\nchar **Var10; \nif (Var7 == 0){\nVar7=2; \nVar10=(char **) FUNC3(memberVar1->memberVar2,sizeof (char *)*Var7,STRING); \nmemset(Var10,0,sizeof (char *)*Var7); \nmemberVar1->memberVar1.memberVar1=Var10; \nmemberVar1->memberVar1.memberVar3=Var7; \n"}, {"FileName": "before.c", "Caller": "gs_add_device_control", "Source": false, "Sink": false, "idx": 29, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1131, "label": -3, "slices": ["static int gs_add_device_control(gs_memory_t *mem, char *device, int len)\n", "    gs_lib_ctx_core_t *core;\n", "    char *buffer;\n", "    uint rlen, n, i;\n", "    if (mem == NULL || mem->gs_lib_ctx == NULL ||\n        (core = mem->gs_lib_ctx->core) == NULL)\n", "    buffer = (char *)gs_alloc_bytes(core->memory, rlen, \"gs_add_device\");\n", "    if (buffer == NULL)\n", "    n = core->permitted_devices.num;\n", "    for (i = 0; i < n; i++)\n", "        if (strlen(core->permitted_devices.devices[i]) == len && strncmp(core->permitted_devices.devices[i], buffer, len) == 0) {\n", "            gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "    if (core->permitted_devices.num == core->permitted_devices.max) {\n", "        char **table;\n", "        n = core->permitted_devices.max * 2;\n", "        if (n == 0) {\n", "            table = (char **)gs_alloc_bytes(core->memory, sizeof(char *) * n, \"gs_add_device_control\");\n", "            if (table == NULL) {\n", "                gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "            memset(table, 0x00, sizeof(char *) * n);\n", "else\n", "            table = (char **)gs_resize_object(core->memory, core->permitted_devices.devices,sizeof(char *) * n, \"gs_add_device_control\");\n", "            if (table == NULL) {\n", "                gs_free_object(core->memory, buffer, \"gs_add_device\");\n", "            memset(table + core->permitted_devices.max, 0x00, core->permitted_devices.max * sizeof(char *));\n", "        core->permitted_devices.devices = table;\n", "        core->permitted_devices.max = n;\n", "    n = core->permitted_devices.num;\n", "    core->permitted_devices.devices[n] = buffer;\n", "    core->permitted_devices.num++;\n"], "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,int  Var3)\nSTRUCT2 *Var4; \nchar *Var5; \nuint  Var6,Var7,Var8; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||\n(Var4=Var1->memberVar1->memberVar1) == NULL )\nVar5=(char *) FUNC2(memberVar1->memberVar1,Var6,STRING); \nif (Var5 == NULL )\nVar7=memberVar1->memberVar2.memberVar1; \nfor (Var8=0; Var8<Var7; Var8  Var9)\nif (strlen(memberVar1->memberVar2.memberVar2[Var8]) ==  Var3&&FUNC3(memberVar1->memberVar2.memberVar2[Var8],Var5,Var3) == 0){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nif (memberVar1->memberVar2.memberVar1 ==  memberVar1->memberVar2.memberVar3){\nchar **Var10; \nVar7=memberVar1->memberVar2.memberVar3 *2; \nif (Var7 == 0){\nVar10=(char **) FUNC2(memberVar1->memberVar1,sizeof (char *)*Var7,STRING); \nif (Var10 == NULL ){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nmemset(Var10,0,sizeof (char *)*Var7); \nelse \nVar10=(char **) FUNC5(memberVar1->memberVar1,memberVar1->memberVar2.memberVar2,sizeof (char *)*Var7,STRING); \nif (Var10 == NULL ){\nFUNC4(memberVar1->memberVar1,Var5,STRING); \nmemset(Var10+memberVar1->memberVar2.memberVar3,0,memberVar1->memberVar2.memberVar3 *sizeof (char *)); \nmemberVar1->memberVar2.memberVar2=Var10; \nmemberVar1->memberVar2.memberVar3=Var7; \nVar7=memberVar1->memberVar2.memberVar1; \nmemberVar1->memberVar2.memberVar2[Var7]=Var5; \nmemberVar1->memberVar2.memberVar1  Var9; \n"}, {"FileName": "before.c", "Caller": "gs_check_device_permission", "Source": false, "Sink": false, "idx": 30, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1154, "label": -3, "slices": ["gs_check_device_permission (gs_memory_t *mem, const char *dname, const int len)\n", "    if (mem->gs_lib_ctx->core->permitted_devices.num != 0) {\n", "        int i;\n", "        char *permit_name = NULL;\n", "        for (i=0;i < mem->gs_lib_ctx->core->permitted_devices.num; i++) {\n", "            permit_name = mem->gs_lib_ctx->core->permitted_devices.devices[i];\n", "            if (permit_name != NULL && strlen(permit_name) == 1 && permit_name[0] == '*')\n", "            if (permit_name != NULL && strlen(permit_name) == len &&\n                strncmp(permit_name, dname, len) == 0)\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2,const int  Var3)\nif (Var1->memberVar1->memberVar1->memberVar1.memberVar1 != 0){\nint  Var4; \nchar *Var5=NULL ; \nfor (Var4=0; Var4<Var1->memberVar1->memberVar1->memberVar1.memberVar1; Var4  Var6){\nVar5=Var1->memberVar1->memberVar1->memberVar1.memberVar2[Var4]; \nif (Var5 != NULL &&strlen(Var5) == 1&&Var5[0]== *)\nif (Var5 != NULL &&strlen(Var5) ==  Var3&&\nFUNC2(Var5,Var2,Var3) == 0)\n"}, {"FileName": "before.c", "Caller": "gs_check_device_permission", "Source": false, "Sink": false, "idx": 31, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1157, "label": -3, "slices": ["gs_check_device_permission (gs_memory_t *mem, const char *dname, const int len)\n", "    if (mem->gs_lib_ctx->core->permitted_devices.num != 0) {\n", "        int i;\n", "        char *permit_name = NULL;\n", "        for (i=0;i < mem->gs_lib_ctx->core->permitted_devices.num; i++) {\n", "            permit_name = mem->gs_lib_ctx->core->permitted_devices.devices[i];\n", "            if (permit_name != NULL && strlen(permit_name) == 1 && permit_name[0] == '*')\n", "            if (permit_name != NULL && strlen(permit_name) == len &&\n                strncmp(permit_name, dname, len) == 0)\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2,const int  Var3)\nif (Var1->memberVar1->memberVar1->memberVar1.memberVar1 != 0){\nint  Var4; \nchar *Var5=NULL ; \nfor (Var4=0; Var4<Var1->memberVar1->memberVar1->memberVar1.memberVar1; Var4  Var6){\nVar5=Var1->memberVar1->memberVar1->memberVar1.memberVar2[Var4]; \nif (Var5 != NULL &&strlen(Var5) == 1&&Var5[0]== *)\nif (Var5 != NULL &&strlen(Var5) ==  Var3&&\nFUNC2(Var5,Var2,Var3) == 0)\n"}, {"FileName": "before.c", "Caller": "gs_add_explicit_permitted_device", "Source": false, "Sink": false, "idx": 32, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1177, "label": -3, "slices": ["gs_add_explicit_permitted_device(gs_memory_t *mem, const char *arg)\n", "    char *p2, *p1 = (char *)arg;\n", "    const char *lim;\n", "    int code = 0;\n", "    if (arg == NULL)\n", "    lim = arg + strlen(arg);\n", "    while (code >= 0 && p1 < lim && (p2 = strchr(p1, gp_file_name_list_separator)) != NULL) {\n", "        code = gs_add_device_control(mem, p1, (int)(p2 - p1));\n", "        p1 = p2 + 1;\n", "    if (p1 < lim)\n", "        code = gs_add_device_control(mem, p1, (int)(lim - p1));\n", "    return code;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nchar *Var3,*Var4=(char *) Var2; \nconst char *Var5; \nint  Var6=0; \nif (Var2 == NULL )\nVar5=Var2+strlen(Var2); \nwhile (Var6 >= 0&&Var4<Var5&&(Var3=strchr(Var4,Var7)) != NULL ){\nVar6=FUNC2(Var1,Var4,(int )(Var3-Var4)); \nVar4=Var3+1; \nif (Var4<Var5)\nVar6=FUNC2(Var1,Var4,(int )(Var5-Var4)); \nreturn  Var6; \n"}, {"FileName": "before.c", "Caller": "gs_add_explicit_permitted_device", "Source": false, "Sink": false, "idx": 33, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1178, "label": -3, "slices": ["gs_add_explicit_permitted_device(gs_memory_t *mem, const char *arg)\n", "    char *p2, *p1 = (char *)arg;\n", "    const char *lim;\n", "    int code = 0;\n", "    if (arg == NULL)\n", "    lim = arg + strlen(arg);\n", "    while (code >= 0 && p1 < lim && (p2 = strchr(p1, gp_file_name_list_separator)) != NULL) {\n", "        code = gs_add_device_control(mem, p1, (int)(p2 - p1));\n", "        p1 = p2 + 1;\n", "    if (p1 < lim)\n", "        code = gs_add_device_control(mem, p1, (int)(lim - p1));\n", "    return code;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nchar *Var3,*Var4=(char *) Var2; \nconst char *Var5; \nint  Var6=0; \nif (Var2 == NULL )\nVar5=Var2+strlen(Var2); \nwhile (Var6 >= 0&&Var4<Var5&&(Var3=strchr(Var4,Var7)) != NULL ){\nVar6=FUNC2(Var1,Var4,(int )(Var3-Var4)); \nVar4=Var3+1; \nif (Var4<Var5)\nVar6=FUNC2(Var1,Var4,(int )(Var5-Var4)); \nreturn  Var6; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_sanitized_arg", "Source": false, "Sink": false, "idx": 34, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1319, "label": -3, "slices": ["gs_lib_ctx_stash_sanitized_arg(gs_lib_ctx_t *ctx, const char *arg)\n", "    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    const char *p;\n", "    int elide = 0;\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    switch(*arg)\n", "        switch (arg[1])\n", "            p = arg+2;\n", "            if (*p == 0)\n", "            if (arg[2] == 0)\n", "            p = arg+2;\n", "            p = arg+2;\n", "            if (*p == 0)\n", "            if (ARG_MATCHES(\"DEFAULTPAPERSIZE\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"DEVICE\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"PAPERSIZE\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"SUBSTFONT\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"ColorConversionStrategy\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"NupControl\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"PageList\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"ProcessColorModel\", arg+2, p-arg-3))\n", "#undef ARG_MATCHES\n", "            arg = \"?\";\n", "        arg = \"?\";\n", "    if (elide)\n", "        len = p-arg;\n", "else\n", "        len = strlen(arg);\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (argv == NULL)\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len+1+elide,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    memcpy(core->argv[core->argc], arg, len);\n", "    if (elide) {\n", "        core->argv[core->argc][len] = '?';\n", "    core->argv[core->argc][len+elide] = 0;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nSTRUCT2 *Var3; \nsize_t  Var4; \nconst char *Var5; \nint  Var6=0; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nswitch (*Var2)\nswitch (Var2[1])\nVar5=Var2+2; \nif (*Var5 == 0)\nif (Var2[2]== 0)\nVar5=Var2+2; \nVar5=Var2+2; \nif (*Var5 == 0)\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nSTRUCT3  FUNC2\nVar2=STRING; \nVar2=STRING; \nif (Var6)\nVar4=Var5-Var2; \nelse \nVar4=strlen(Var2); \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var7; \nint  Var8=memberVar1->memberVar1 *2; \nif (Var7 == NULL )\nmemberVar1->memberVar3[memberVar1->memberVar2]=(char *) FUNC3(Var1->memberVar1->memberVar4,Var4+1+Var6,\nSTRING); \nif (memberVar1->memberVar3[memberVar1->memberVar2]== NULL )\nmemcpy(memberVar1->memberVar3[memberVar1->memberVar2],Var2,Var4); \nif (Var6){\nmemberVar1->memberVar3[memberVar1->memberVar2][Var4]=; \nmemberVar1->memberVar3[memberVar1->memberVar2][Var4+Var6]=0; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_sanitized_arg", "Source": false, "Sink": false, "idx": 35, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 1331, "label": -3, "slices": ["gs_lib_ctx_stash_sanitized_arg(gs_lib_ctx_t *ctx, const char *arg)\n", "    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    int elide = 0;\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "#undef ARG_MATCHES\n", "    core = ctx->core;\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (newlen == 0)\n", "            newlen = 4;\n", "        argv = (char **)gs_alloc_bytes(ctx->core->memory, sizeof(char *) * newlen,\n                                       \"gs_lib_ctx_args\");\n", "        if (argv == NULL)\n", "        if (core->argc > 0) {\n", "            memcpy(argv, core->argv, sizeof(char *) * core->argc);\n", "            gs_free_object(ctx->memory, core->argv, \"gs_lib_ctx_args\");\n", "        core->argv = argv;\n", "        core->arg_max = newlen;\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len+1+elide,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    memcpy(core->argv[core->argc], arg, len);\n", "    if (elide) {\n", "        core->argv[core->argc][len] = '?';\n", "    core->argv[core->argc][len+elide] = 0;\n", "    core->argc++;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nSTRUCT2 *Var3; \nsize_t  Var4; \nint  Var5=0; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nSTRUCT3  Var6\nmemberVar1=Var1->memberVar1; \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var7; \nint  Var8=memberVar1->memberVar1 *2; \nif (Var8 == 0)\nVar8=4; \nVar7=(char **) FUNC2(Var1->memberVar1->memberVar3,sizeof (char *)*Var8,\nSTRING); \nif (Var7 == NULL )\nif (memberVar1->memberVar2>0){\nmemcpy(Var7,memberVar1->memberVar4,sizeof (char *)*memberVar1->memberVar2); \nFUNC3(Var1->memberVar2,memberVar1->memberVar4,STRING); \nmemberVar1->memberVar4=memberVar4; \nmemberVar1->memberVar1=Var8; \nmemberVar1->memberVar4[memberVar1->memberVar2]=(char *) FUNC2(Var1->memberVar1->memberVar3,Var4+1+Var5,\nSTRING); \nif (memberVar1->memberVar4[memberVar1->memberVar2]== NULL )\nmemcpy(memberVar1->memberVar4[memberVar1->memberVar2],Var2,Var4); \nif (Var5){\nmemberVar1->memberVar4[memberVar1->memberVar2][Var4]=; \nmemberVar1->memberVar4[memberVar1->memberVar2][Var4+Var5]=0; \nmemberVar1->memberVar2  Var9; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_sanitized_arg", "Source": false, "Sink": false, "idx": 36, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 1342, "label": -3, "slices": ["gs_lib_ctx_stash_sanitized_arg(gs_lib_ctx_t *ctx, const char *arg)\n", "    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    const char *p;\n", "    int elide = 0;\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    switch(*arg)\n", "        switch (arg[1])\n", "            p = arg+2;\n", "            while (*p && *p != '=' && *p != '#')\n", "                p++;\n", "            if (*p == '=' || *p == '#')\n", "                p++;\n", "            if (*p == 0)\n", "            if (ARG_MATCHES(\"permit-file-read\", arg+2, p-arg-3))\n", "                elide=1;\n", "            if (ARG_MATCHES(\"permit-file-write\", arg+2, p-arg-3))\n", "                elide=1;\n", "            if (ARG_MATCHES(\"permit-file-control\", arg+2, p-arg-3))\n", "                elide=1;\n", "            if (ARG_MATCHES(\"permit-file-all\", arg+2, p-arg-3))\n", "                elide=1;\n", "            if (arg[2] == 0)\n", "            p = arg+2;\n", "            while (*p == 32)\n", "                p++;\n", "            elide = 1;\n", "            p = arg+2;\n", "            while (*p && *p != '=' && *p != '#')\n", "                p++;\n", "            if (*p == '=' || *p == '#')\n", "                p++;\n", "            if (*p == 0)\n", "            if (ARG_MATCHES(\"DEFAULTPAPERSIZE\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"DEVICE\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"PAPERSIZE\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"SUBSTFONT\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"ColorConversionStrategy\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"NupControl\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"PageList\", arg+2, p-arg-3))\n", "            if (ARG_MATCHES(\"ProcessColorModel\", arg+2, p-arg-3))\n", "#undef ARG_MATCHES\n", "            arg = \"?\";\n", "        arg = \"?\";\n", "    core = ctx->core;\n", "    if (elide)\n", "        len = p-arg;\n", "else\n", "        len = strlen(arg);\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (newlen == 0)\n", "            newlen = 4;\n", "        argv = (char **)gs_alloc_bytes(ctx->core->memory, sizeof(char *) * newlen,\n                                       \"gs_lib_ctx_args\");\n", "        if (argv == NULL)\n", "        if (core->argc > 0) {\n", "            memcpy(argv, core->argv, sizeof(char *) * core->argc);\n", "            gs_free_object(ctx->memory, core->argv, \"gs_lib_ctx_args\");\n", "        core->argv = argv;\n", "        core->arg_max = newlen;\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len+1+elide,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    memcpy(core->argv[core->argc], arg, len);\n", "    if (elide) {\n", "        core->argv[core->argc][len] = '?';\n", "    core->argv[core->argc][len+elide] = 0;\n", "    core->argc++;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nSTRUCT2 *Var3; \nsize_t  Var4; \nconst char *Var5; \nint  Var6=0; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nswitch (*Var2)\nswitch (Var2[1])\nVar5=Var2+2; \nwhile (*Var5&&*Var5 != =&&*Var5 != )\nVar5  Var7; \nif (*Var5 == =||*Var5 == )\nVar5  Var7; \nif (*Var5 == 0)\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nVar6=1; \nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nVar6=1; \nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nVar6=1; \nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nVar6=1; \nif (Var2[2]== 0)\nVar5=Var2+2; \nwhile (*Var5 == 32)\nVar5  Var7; \nVar6=1; \nVar5=Var2+2; \nwhile (*Var5&&*Var5 != =&&*Var5 != )\nVar5  Var7; \nif (*Var5 == =||*Var5 == )\nVar5  Var7; \nif (*Var5 == 0)\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nif (FUNC2(STRING,Var2+2,Var5-Var2-3))\nSTRUCT3  FUNC2\nVar2=STRING; \nVar2=STRING; \nmemberVar1=Var1->memberVar1; \nif (Var6)\nVar4=Var5-Var2; \nelse \nVar4=strlen(Var2); \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var8; \nint  Var9=memberVar1->memberVar1 *2; \nif (Var9 == 0)\nVar9=4; \nVar8=(char **) FUNC3(Var1->memberVar1->memberVar3,sizeof (char *)*Var9,\nSTRING); \nif (Var8 == NULL )\nif (memberVar1->memberVar2>0){\nmemcpy(Var8,memberVar1->memberVar4,sizeof (char *)*memberVar1->memberVar2); \nFUNC4(Var1->memberVar2,memberVar1->memberVar4,STRING); \nmemberVar1->memberVar4=memberVar4; \nmemberVar1->memberVar1=Var9; \nmemberVar1->memberVar4[memberVar1->memberVar2]=(char *) FUNC3(Var1->memberVar1->memberVar3,Var4+1+Var6,\nSTRING); \nif (memberVar1->memberVar4[memberVar1->memberVar2]== NULL )\nmemcpy(memberVar1->memberVar4[memberVar1->memberVar2],Var2,Var4); \nif (Var6){\nmemberVar1->memberVar4[memberVar1->memberVar2][Var4]=; \nmemberVar1->memberVar4[memberVar1->memberVar2][Var4+Var6]=0; \nmemberVar1->memberVar2  Var7; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_exe", "Source": false, "Sink": false, "idx": 37, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1359, "label": -3, "slices": ["    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    const char *p, *word;\n", "    const char *sep = gp_file_name_directory_separator();\n", "    size_t seplen = strlen(sep);\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    for (p = arg; *p; p++) {\n", "        if (memcmp(sep, p, seplen) == 0) {\n", "            word = p+seplen;\n", "            p += seplen-1;\n", "        if (*p == '\\\\')\n", "            word = p+1;\n", "    len = p - (word ? word : arg) + 1;\n", "    if (word)\n", "        len += 5;\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (argv == NULL)\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    if (word)\n", "        strcpy(core->argv[core->argc], \"path/\");\n", "else\n", "        core->argv[core->argc][0] = 0;\n", "    strcat(core->argv[core->argc], word ? word : arg);\n"], "tokenized": "STRUCT1 *Var1; \nsize_t  Var2; \nconst char *Var3,*Var4; \nconst char *Var5=FUNC1(); \nsize_t  Var6=strlen(Var5); \nif (Var7 == NULL ||Var7->memberVar1 == NULL ||Var8 == NULL )\nfor (Var3=Var8; *Var3; Var3  Var9){\nif (memcmp(Var5,Var3,Var6) == 0){\nVar4=Var3+Var6; \nVar3  STRUCT2  Var6-1; \nif (*Var3 == )\nVar4=Var3+1; \nVar2=Var3-(Var4  Var4  Var8)+1; \nif (Var4)\nVar2  STRUCT2 5; \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var10; \nint  Var11=memberVar1->memberVar1 *2; \nif (Var10 == NULL )\nmemberVar1->memberVar3[memberVar1->memberVar2]=(char *) FUNC2(Var7->memberVar1->memberVar4,Var2,\nSTRING); \nif (memberVar1->memberVar3[memberVar1->memberVar2]== NULL )\nif (Var4)\nstrcpy(memberVar1->memberVar3[memberVar1->memberVar2],STRING); \nelse \nmemberVar1->memberVar3[memberVar1->memberVar2][0]=0; \nstrcat(memberVar1->memberVar3[memberVar1->memberVar2],Var4  Var4  Var8); \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_exe", "Source": false, "Sink": false, "idx": 38, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcmp", "line": 1368, "label": -3, "slices": ["gs_lib_ctx_stash_exe(gs_lib_ctx_t *ctx, const char *arg)\n", "    size_t len;\n", "    const char *p, *word;\n", "    const char *sep = gp_file_name_directory_separator();\n", "    size_t seplen = strlen(sep);\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    for (p = arg; *p; p++) {\n", "        if (memcmp(sep, p, seplen) == 0) {\n", "            word = p+seplen;\n", "            p += seplen-1;\n", "        if (*p == '\\\\')\n", "            word = p+1;\n", "    len = p - (word ? word : arg) + 1;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nsize_t  Var3; \nconst char *Var4,*Var5; \nconst char *Var6=FUNC2(); \nsize_t  Var7=strlen(Var6); \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nfor (Var4=Var2; *Var4; Var4  Var8){\nif (memcmp(Var6,Var4,Var7) == 0){\nVar5=Var4+Var7; \nVar4  STRUCT2  Var7-1; \nif (*Var4 == )\nVar5=Var4+1; \nVar3=Var4-(Var5  Var5  Var2)+1; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_exe", "Source": false, "Sink": false, "idx": 39, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 1392, "label": -3, "slices": ["gs_lib_ctx_stash_exe(gs_lib_ctx_t *ctx, const char *arg)\n", "    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    const char *p, *word;\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    core = ctx->core;\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (newlen == 0)\n", "            newlen = 4;\n", "        argv = (char **)gs_alloc_bytes(ctx->core->memory, sizeof(char *) * newlen,\n                                       \"gs_lib_ctx_args\");\n", "        if (argv == NULL)\n", "        if (core->argc > 0) {\n", "            memcpy(argv, core->argv, sizeof(char *) * core->argc);\n", "            gs_free_object(ctx->memory, core->argv, \"gs_lib_ctx_args\");\n", "        core->argv = argv;\n", "        core->arg_max = newlen;\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    if (word)\n", "        strcpy(core->argv[core->argc], \"path/\");\n", "else\n", "        core->argv[core->argc][0] = 0;\n", "    strcat(core->argv[core->argc], word ? word : arg);\n", "    core->argc++;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nSTRUCT2 *Var3; \nsize_t  Var4; \nconst char *Var5,*Var6; \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nmemberVar1=Var1->memberVar1; \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var7; \nint  Var8=memberVar1->memberVar1 *2; \nif (Var8 == 0)\nVar8=4; \nVar7=(char **) FUNC2(Var1->memberVar1->memberVar3,sizeof (char *)*Var8,\nSTRING); \nif (Var7 == NULL )\nif (memberVar1->memberVar2>0){\nmemcpy(Var7,memberVar1->memberVar4,sizeof (char *)*memberVar1->memberVar2); \nFUNC3(Var1->memberVar2,memberVar1->memberVar4,STRING); \nmemberVar1->memberVar4=memberVar4; \nmemberVar1->memberVar1=Var8; \nmemberVar1->memberVar4[memberVar1->memberVar2]=(char *) FUNC2(Var1->memberVar1->memberVar3,Var4,\nSTRING); \nif (memberVar1->memberVar4[memberVar1->memberVar2]== NULL )\nif (Var6)\nstrcpy(memberVar1->memberVar4[memberVar1->memberVar2],STRING); \nelse \nmemberVar1->memberVar4[memberVar1->memberVar2][0]=0; \nstrcat(memberVar1->memberVar4[memberVar1->memberVar2],Var6  Var6  Var2); \nmemberVar1->memberVar2  Var9; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_exe", "Source": false, "Sink": false, "idx": 40, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 1404, "label": -3, "slices": ["gs_lib_ctx_stash_exe(gs_lib_ctx_t *ctx, const char *arg)\n", "    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    const char *p, *word;\n", "    const char *sep = gp_file_name_directory_separator();\n", "    size_t seplen = strlen(sep);\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    word = NULL;\n", "    for (p = arg; *p; p++) {\n", "        if (memcmp(sep, p, seplen) == 0) {\n", "            word = p+seplen;\n", "            p += seplen-1;\n", "        if (*p == '\\\\')\n", "            word = p+1;\n", "    len = p - (word ? word : arg) + 1;\n", "    if (word)\n", "        len += 5;\n", "    core = ctx->core;\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (newlen == 0)\n", "            newlen = 4;\n", "        argv = (char **)gs_alloc_bytes(ctx->core->memory, sizeof(char *) * newlen,\n                                       \"gs_lib_ctx_args\");\n", "        if (argv == NULL)\n", "        if (core->argc > 0) {\n", "            memcpy(argv, core->argv, sizeof(char *) * core->argc);\n", "            gs_free_object(ctx->memory, core->argv, \"gs_lib_ctx_args\");\n", "        core->argv = argv;\n", "        core->arg_max = newlen;\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    if (word)\n", "        strcpy(core->argv[core->argc], \"path/\");\n", "else\n", "        core->argv[core->argc][0] = 0;\n", "    strcat(core->argv[core->argc], word ? word : arg);\n", "    core->argc++;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nSTRUCT2 *Var3; \nsize_t  Var4; \nconst char *Var5,*Var6; \nconst char *Var7=FUNC2(); \nsize_t  Var8=strlen(Var7); \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nVar6=NULL ; \nfor (Var5=Var2; *Var5; Var5  Var9){\nif (memcmp(Var7,Var5,Var8) == 0){\nVar6=Var5+Var8; \nVar5  STRUCT3  Var8-1; \nif (*Var5 == )\nVar6=Var5+1; \nVar4=Var5-(Var6  Var6  Var2)+1; \nif (Var6)\nVar4  STRUCT3 5; \nmemberVar1=Var1->memberVar1; \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var10; \nint  Var11=memberVar1->memberVar1 *2; \nif (Var11 == 0)\nVar11=4; \nVar10=(char **) FUNC3(Var1->memberVar1->memberVar3,sizeof (char *)*Var11,\nSTRING); \nif (Var10 == NULL )\nif (memberVar1->memberVar2>0){\nmemcpy(Var10,memberVar1->memberVar4,sizeof (char *)*memberVar1->memberVar2); \nFUNC4(Var1->memberVar2,memberVar1->memberVar4,STRING); \nmemberVar1->memberVar4=memberVar4; \nmemberVar1->memberVar1=Var11; \nmemberVar1->memberVar4[memberVar1->memberVar2]=(char *) FUNC3(Var1->memberVar1->memberVar3,Var4,\nSTRING); \nif (memberVar1->memberVar4[memberVar1->memberVar2]== NULL )\nif (Var6)\nstrcpy(memberVar1->memberVar4[memberVar1->memberVar2],STRING); \nelse \nmemberVar1->memberVar4[memberVar1->memberVar2][0]=0; \nstrcat(memberVar1->memberVar4[memberVar1->memberVar2],Var6  Var6  Var2); \nmemberVar1->memberVar2  Var9; \n"}, {"FileName": "before.c", "Caller": "gs_lib_ctx_stash_exe", "Source": false, "Sink": false, "idx": 41, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcat", "line": 1407, "label": -3, "slices": ["gs_lib_ctx_stash_exe(gs_lib_ctx_t *ctx, const char *arg)\n", "    gs_lib_ctx_core_t *core;\n", "    size_t len;\n", "    const char *p, *word;\n", "    const char *sep = gp_file_name_directory_separator();\n", "    size_t seplen = strlen(sep);\n", "    if (ctx == NULL || ctx->core == NULL || arg == NULL)\n", "    p = arg;\n", "    word = NULL;\n", "    for (p = arg; *p; p++) {\n", "        if (memcmp(sep, p, seplen) == 0) {\n", "            word = p+seplen;\n", "            p += seplen-1;\n", "        if (*p == '\\\\')\n", "            word = p+1;\n", "    len = p - (word ? word : arg) + 1;\n", "    if (word)\n", "        len += 5;\n", "    core = ctx->core;\n", "    if (core->arg_max == core->argc) {\n", "        char **argv;\n", "        int newlen = core->arg_max * 2;\n", "        if (newlen == 0)\n", "            newlen = 4;\n", "        argv = (char **)gs_alloc_bytes(ctx->core->memory, sizeof(char *) * newlen,\n                                       \"gs_lib_ctx_args\");\n", "        if (argv == NULL)\n", "        if (core->argc > 0) {\n", "            memcpy(argv, core->argv, sizeof(char *) * core->argc);\n", "            gs_free_object(ctx->memory, core->argv, \"gs_lib_ctx_args\");\n", "        core->argv = argv;\n", "        core->arg_max = newlen;\n", "    core->argv[core->argc] = (char *)gs_alloc_bytes(ctx->core->memory, len,\n                                                    \"gs_lib_ctx_arg\");\n", "    if (core->argv[core->argc] == NULL)\n", "    if (word)\n", "        strcpy(core->argv[core->argc], \"path/\");\n", "else\n", "        core->argv[core->argc][0] = 0;\n", "    strcat(core->argv[core->argc], word ? word : arg);\n", "    core->argc++;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char *Var2)\nSTRUCT2 *Var3; \nsize_t  Var4; \nconst char *Var5,*Var6; \nconst char *Var7=FUNC2(); \nsize_t  Var8=strlen(Var7); \nif (Var1 == NULL ||Var1->memberVar1 == NULL ||Var2 == NULL )\nVar5=Var2; \nVar6=NULL ; \nfor (Var5=Var2; *Var5; Var5  Var9){\nif (memcmp(Var7,Var5,Var8) == 0){\nVar6=Var5+Var8; \nVar5  STRUCT3  Var8-1; \nif (*Var5 == )\nVar6=Var5+1; \nVar4=Var5-(Var6  Var6  Var2)+1; \nif (Var6)\nVar4  STRUCT3 5; \nmemberVar1=Var1->memberVar1; \nif (memberVar1->memberVar1 ==  memberVar1->memberVar2){\nchar **Var10; \nint  Var11=memberVar1->memberVar1 *2; \nif (Var11 == 0)\nVar11=4; \nVar10=(char **) FUNC3(Var1->memberVar1->memberVar3,sizeof (char *)*Var11,\nSTRING); \nif (Var10 == NULL )\nif (memberVar1->memberVar2>0){\nmemcpy(Var10,memberVar1->memberVar4,sizeof (char *)*memberVar1->memberVar2); \nFUNC4(Var1->memberVar2,memberVar1->memberVar4,STRING); \nmemberVar1->memberVar4=memberVar4; \nmemberVar1->memberVar1=Var11; \nmemberVar1->memberVar4[memberVar1->memberVar2]=(char *) FUNC3(Var1->memberVar1->memberVar3,Var4,\nSTRING); \nif (memberVar1->memberVar4[memberVar1->memberVar2]== NULL )\nif (Var6)\nstrcpy(memberVar1->memberVar4[memberVar1->memberVar2],STRING); \nelse \nmemberVar1->memberVar4[memberVar1->memberVar2][0]=0; \nstrcat(memberVar1->memberVar4[memberVar1->memberVar2],Var6  Var6  Var2); \nmemberVar1->memberVar2  Var9; \n"}, {"FileName": "before.c", "Caller": "gs_globals_init", "Source": false, "Sink": false, "idx": 42, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memset", "line": 1526, "label": -3, "slices": ["void gs_globals_init(gs_globals *globals)\n", "    memset(globals, 0, sizeof(*globals));\n"], "tokenized": "void FUNC1(STRUCT1 *Var1)\nmemset(Var1,0,sizeof (*Var1)); \n"}]