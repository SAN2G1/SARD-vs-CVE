# 📁 CVE-2015-8617

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/php/php-src/commit/b101a6bbd4f2181c360bd38e7683df4a03cba83e)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2015-8617)**  | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/134.html)** 

> PHP 7.0.1 이전 버전의 `Zend/zend_execute_API.c`의 `zend_throw_or_error` 함수 내부에서 외부 입력을 문자열 메시지로 포맷팅한 후, `zend_throw_error()`를 통해 포맷 문자열 해석이 이루어지는 방식에서 발생하는 \*\*형식 문자열 취약점(CWE-134)\*\*입니다. 공격자가 포맷 문자열을 조작하여 임의 코드 실행이나 비정상 동작을 유발할 수 있습니다.

* **Source**: 외부에서 제어 가능한 상수 이름(예: 클래스명 문자열)
* **취약 조건**: 상수가 존재하지 않을 때 예외 메시지를 출력하며 포맷 문자열에 유입됨
* **Sink**: `zend_throw_error()` – 포맷 문자열이 실제로 해석되는 함수

---

## 탐지 결과 요약

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
| -------- | ------- | ------- |
| 0개      | 0개      | 0개     |

\* Sink(`end_throw_error` 함수) 관련 슬라이스는 존재하지 않음


`<?php $name="%n%n%n"; $name::doSomething(); ?>`

참고: https://bugs.php.net/bug.php?id=71105

이 CVE 취약점을 유발하는 코드(sink:zend_execute_API.c:221)는 아래와 같다.
```
static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) {
	va_list va;
	char *message = NULL;

	va_start(va, format);
	zend_vspprintf(&message, 0, format, va);

	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, message);
}
```
이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.

```c

/* Zend/zend_execute_API:1368 */
zend_class_entry *zend_fetch_class(zend_string *class_name, int fetch_type) /* {{{ */
{
	zend_class_entry *ce;
	int fetch_sub_type = fetch_type & ZEND_FETCH_CLASS_MASK;
check_fetch_type:
	if (fetch_type & ZEND_FETCH_CLASS_NO_AUTOLOAD) {
	} else if ((ce = zend_lookup_class_ex(class_name, NULL, 1)) == NULL) {
		if (!(fetch_type & ZEND_FETCH_CLASS_SILENT) && !EG(exception)) {
			if (fetch_sub_type == ZEND_FETCH_CLASS_INTERFACE) {
			} else if (fetch_sub_type == ZEND_FETCH_CLASS_TRAIT) {
			} else {
				zend_throw_or_error(fetch_type, NULL, "Class '%s' not found", ZSTR_VAL(class_name));
			}
		}
		return NULL;
	}
	return ce;
}
/* }}} */

/* Zend/zend_execute_API:1390 */
zend_class_entry *zend_fetch_class_by_name(zend_string *class_name, const zval *key, int fetch_type) /* {{{ */
{
	zend_class_entry *ce;
	if (fetch_type & ZEND_FETCH_CLASS_NO_AUTOLOAD) {
	} else if ((ce = zend_lookup_class_ex(class_name, key, 1)) == NULL) {
		if ((fetch_type & ZEND_FETCH_CLASS_SILENT) == 0 && !EG(exception)) {
			if ((fetch_type & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_INTERFACE) {
			} else if ((fetch_type & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_TRAIT) {
			} else {
				zend_throw_or_error(fetch_type, NULL, "Class '%s' not found", ZSTR_VAL(class_name));
}

/* Zend/zend_execute_API.c:221 */
static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) {
	va_list va;
	char *message = NULL;

	va_start(va, format);
	zend_vspprintf(&message, 0, format, va);

	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, message);
}

/* Zend/zend.c:1313 */
ZEND_API ZEND_COLD void zend_throw_error(zend_class_entry *exception_ce, const char *format, ...) /* {{{ */
{
	va_list va;
	char *message = NULL;
	
	if (exception_ce) {
		if (!instanceof_function(exception_ce, zend_ce_error)) {
			zend_error(E_NOTICE, "Error exceptions must be derived from Error");
			exception_ce = zend_ce_error;
		}
	} else {
		exception_ce = zend_ce_error;
	}

	va_start(va, format);
	zend_vspprintf(&message, 0, format, va);

/* Zend/zend.c:632 */
int zend_startup(zend_utility_functions *utility_functions, char **extensions) /* {{{ */
{
#ifdef ZTS
	zend_compiler_globals *compiler_globals;
	zend_executor_globals *executor_globals;
	extern ZEND_API ts_rsrc_id ini_scanner_globals_id;
	extern ZEND_API ts_rsrc_id language_scanner_globals_id;
	ZEND_TSRMLS_CACHE_UPDATE();
#else
	extern zend_ini_scanner_globals ini_scanner_globals;
	extern zend_php_scanner_globals language_scanner_globals;
#endif

	start_memory_manager();

	virtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */

#if defined(__FreeBSD__) || defined(__DragonFly__)
	/* FreeBSD and DragonFly floating point precision fix */
	fpsetmask(0);
#endif

	zend_startup_strtod();
	zend_startup_extensions_mechanism();

	/* Set up utility functions and values */
	zend_error_cb = utility_functions->error_function;
	zend_printf = utility_functions->printf_function;
	zend_write = (zend_write_func_t) utility_functions->write_function;
	zend_fopen = utility_functions->fopen_function;
	if (!zend_fopen) {
		zend_fopen = zend_fopen_wrapper;
	}
	zend_stream_open_function = utility_functions->stream_open_function;
	zend_message_dispatcher_p = utility_functions->message_handler;
#ifndef ZEND_SIGNALS
	zend_block_interruptions = utility_functions->block_interruptions;
	zend_unblock_interruptions = utility_functions->unblock_interruptions;
#endif
	zend_get_configuration_directive_p = utility_functions->get_configuration_directive;
	zend_ticks_function = utility_functions->ticks_function;
	zend_on_timeout = utility_functions->on_timeout;
	zend_vspprintf = utility_functions->vspprintf_function;

/* main/main.c:2058 */
int php_module_startup(sapi_module_struct *sf, zend_module_entry *additional_modules, uint num_additional_modules)
{
	zend_utility_functions zuf;
    zuf.vspprintf_function = vspprintf;
	zuf.vstrpprintf_function = vstrpprintf;
	zuf.getenv_function = sapi_getenv;
	zuf.resolve_path_function = php_resolve_path_for_zend;
	zend_startup(&zuf, NULL);

/* main/spprintf.c:847 */
PHPAPI size_t vspprintf(char **pbuf, size_t max_len, const char *format, va_list ap) /* {{{ */
{
	smart_string buf = {0};

	/* since there are places where (v)spprintf called without checking for null,
	   a bit of defensive coding here */
	if(!pbuf) {
		return 0;
	}
	xbuf_format_converter(&buf, 1, format, ap);
}

/* main/spprintf.c:744 */

	while (*fmt) {
		if (*fmt != '%') {
			INS_CHAR(xbuf, *fmt, is_char);
		} else {
			/*
			 * Default variable settings
			 */
			adjust = RIGHT;
			alternate_form = print_sign = print_blank = NO;
			pad_char = ' ';
			prefix_char = NUL;
			free_zcopy = 0;

			fmt++;

			/*
			 * Try to avoid checking for flags, width or precision
			 */
			if (isascii((int)*fmt) && !islower((int)*fmt)) {
				/*
				 * Recognize flags: -, #, BLANK, +
				 */
				for (;; fmt++) {
					if (*fmt == '-')
						adjust = LEFT;
					else if (*fmt == '+')
						print_sign = YES;
					else if (*fmt == '#')
						alternate_form = YES;
					else if (*fmt == ' ')
						print_blank = YES;
					else if (*fmt == '0')
						pad_char = '0';
					else
						break;
				}

				/*
				 * Check if a width was specified
				 */
				if (isdigit((int)*fmt)) {
					STR_TO_DEC(fmt, min_width);
					adjust_width = YES;
				} else if (*fmt == '*') {
					min_width = va_arg(ap, int);
					fmt++;
					adjust_width = YES;
					if (min_width < 0) {
						adjust = LEFT;
						min_width = -min_width;
					}
				} else
					adjust_width = NO;

				/*
				 * Check if a precision was specified
				 */
				if (*fmt == '.') {
					adjust_precision = YES;
					fmt++;
					if (isdigit((int)*fmt)) {
						STR_TO_DEC(fmt, precision);
					} else if (*fmt == '*') {
						precision = va_arg(ap, int);
						fmt++;
						if (precision < 0)
							precision = 0;
					} else
						precision = 0;

					if (precision > FORMAT_CONV_MAX_PRECISION) {
						precision = FORMAT_CONV_MAX_PRECISION;
					}
				} else
					adjust_precision = NO;
			} else
				adjust_precision = adjust_width = NO;

			/*
			 * Modifier check
			 */
            switch (*fmt) {
                ...
				case 'n':
					*(va_arg(ap, int *)) = is_char? (int)((smart_string *)xbuf)->len : (int)ZSTR_LEN(((smart_str *)xbuf)->s);
```

이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

---

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **부적절한 criterion**
   * 이 취약점의 경우 criterion으로 `zend_throw_error`가 잡히지 않아 정상으로 판단된 것으로 보임.

---

## 취약점 세부 사항

### ❗️취약 코드

#### Sink: `before_zend_execute_API.c:221`

```c
zend_throw_error(exception_ce, message);
```

**문제점**:
* `message`는 외부 입력을 포함한 포맷 문자열로 `zend_vspprintf()`에서 생성됨
* 이 문자열이 포맷 문자열로 그대로 해석되어 CWE-134 취약점 발생 가능

### ✅ 개선 코드

**패치 위치**: `after_zend_execute_API.c:221`

```c
zend_throw_error(exception_ce, "%s", message);
```

**개선 방법**:

* 외부 입력이 포함된 문자열을 포맷 문자열로 직접 사용하지 않고, 고정된 `"%s"`를 사용해 안전하게 출력함
* 이로써 포맷 문자열 취약점(CWE-134) 발생 가능성 제거

---

## 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출
* 없음