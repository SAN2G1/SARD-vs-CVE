# ğŸ“ CVE-2017-12588

## ğŸ” ì·¨ì•½ì  ê°œìš”

**ğŸ”— [ì»¤ë°‹ ë§í¬](https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b)** | **ğŸ”— [CVE ë§í¬](https://www.cvedetails.com/cve/CVE-2017-12588/)**  | **ğŸ”— [CWE ë§í¬](https://cwe.mitre.org/data/definitions/134.html)**  


> rsyslog 8.28.0 ì´ì „ ë²„ì „ì˜ `omzmq3` ë° `imzmq3` ëª¨ë“ˆì—ì„œëŠ” ì„¤ëª…(description) í•„ë“œê°€ í˜•ì‹ ë¬¸ìì—´ë¡œ í•´ì„ë˜ëŠ” ë¬¸ì œê°€ ì¡´ì¬í•©ë‹ˆë‹¤.  
> ì´ë¡œ ì¸í•´ ê³µê²©ìëŠ” í¬ë§· ë¬¸ìì—´ ì§€ì •ìë¥¼ í¬í•¨í•œ ì…ë ¥ì„ í†µí•´ **í˜•ì‹ ë¬¸ìì—´ ì·¨ì•½ì (CWE-134)**ì„ ìœ ë°œí•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ì„œë¹„ìŠ¤ ê±°ë¶€ ë˜ëŠ” ë©”ëª¨ë¦¬ ì¡°ì‘ê³¼ ê°™ì€ ì˜í–¥ì„ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* **Source**: ì„¤ëª… ë¬¸ìì—´(`info->description`) â€“ ì™¸ë¶€ ì…ë ¥ì— ì˜í•´ ì„¤ì •ë  ìˆ˜ ìˆìŒ
* **ì·¨ì•½ ì¡°ê±´**: ì„¤ëª…(description) ë¬¸ìì—´ì— í¬ë§· ë¬¸ìì—´ ì§€ì •ì(`%s`, `%x` ë“±)ê°€ í¬í•¨ëœ ê²½ìš°, í•´ë‹¹ ë¬¸ìì—´ì´ í¬ë§· ë¬¸ìì—´ë¡œ ì§ì ‘ ì‚¬ìš©ë¨
* **Sink**: `zsocket_connect()`, `zsocket_bind()` â€“ ë‚´ë¶€ì ìœ¼ë¡œ `printf` ê³„ì—´ í•¨ìˆ˜ì— format stringìœ¼ë¡œ ì „ë‹¬ë¨

---

## íƒì§€ ê²°ê³¼ ìš”ì•½

| ì´ ìŠ¬ë¼ì´ìŠ¤ ìˆ˜ | ì·¨ì•½ìœ¼ë¡œ íƒì§€ | ì •ìƒìœ¼ë¡œ íƒì§€ |
|----------------|----------------|----------------|
| 0ê°œ           | 0ê°œ            | 0ê°œ           |

\* Sink(`zsocket_connect` í•¨ìˆ˜) ê´€ë ¨ ìŠ¬ë¼ì´ìŠ¤ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒ.

1. rsyslogdê°€ ì‹œì‘ë˜ì–´ì„œ conf íŒŒì¼ì„ ì½ê³ ,
2. newActInst ëª¨ë“ˆ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì„œ pDataì˜ description ê´€ë ¨ í•„ë“œì— í¬ë§· ì—ëŸ¬ì™€ ê´€ë ¨ëœ ì•…ì„± ìŠ¤íŠ¸ë§ì„ ì„¤ì •í•˜ê³ 
3. doAction ëª¨ë“ˆ í•¨ìˆ˜ë‚˜, tryResume ëª¨ë“ˆ í•¨ìˆ˜ê°€ ë¶ˆë ¸ì„ ë•Œ
4. zsocket_connectë¥¼ í˜¸ì¶œí•  ë–„, description ìŠ¤íŠ¸ë§ì„ í¬ë§· ìŠ¤íŠ¸ë§ìœ¼ë¡œ ì‚¬ìš©í•´ì„œ ì·¨ì•½ì ì´ ë°œìƒí•œë‹¤.

ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë‘ê°œë¥¼ í•™ìŠµì„ ì‹œì¼œì•¼ í•œë‹¤. ê¸°ì¡´ì—ëŠ” ì·¨ì•½ì ì„ í•˜ë‚˜ì˜ ì·¨ì•½ì ìœ¼ë¡œ ì •ì˜í•˜ê³ ì í–ˆìœ¼ë‚˜, ê±°ê¸°ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ì‚¬ë¡€ë¡œ ë³´ì¸ë‹¤.

newActionInst í›„ì— doActionì´ë‚˜ tryResumeì´ í˜¸ì¶œëœë‹¤ëŠ” ë³´ì¥ì´ ì—†ê¸° ë•Œë¬¸ì—

ì´ CVE ì·¨ì•½ì ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œ(sink:contrib/omzmq3/omzmq3.c:245)ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.
```
static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    if (NULL == s_context) {
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
    if (pData->action == ACTION_BIND) {
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
```
ì´ ì½”ë“œì—ì„œ Ksign ìŠ¬ë¼ì´ì„œ ë„êµ¬ê°€ ì¶”ì¶œí–ˆì–´ì•¼ í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.



```
// ì•„ë˜ì™€ ê°™ì´ ,ê°€ ì—†ëŠ”ê²Œ ë§ë‹¤.
/* descriptionì— %nì„ ë„£ìœ¼ë©´ format string bug ë°œìƒ ! */
// https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/deployment_guide/s1-basic_configuration_of_rsyslog
if $programname == 'prog1' then {
   action(type="omfile" file="/var/log/prog1.log")
   if $msg contains 'test' then
     action(type="omfile" file="/var/log/prog1test.log")
   else
     action(type="omfile" file="/var/log/prog1notest.log")
}

```


```c
/* rsyslogd.c:1407 */
rsconf_t *ourConf = NULL;
uchar *ConfFile = (uchar*) "/etc/rsyslog.conf";

static void
initAll(int argc, char **argv)
{
	...
	localRet = rsconf.Load(&ourConf, ConfFile);

/* runtime/rsconf.c:1391 */
BEGINobjQueryInterface(rsconf)
CODESTARTobjQueryInterface(rsconf)
	if(pIf->ifVersion != rsconfCURR_IF_VERSION) { /* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}

	/* ok, we have the right interface, so let's fill it
	 * Please note that we may also do some backwards-compatibility
	 * work here (if we can support an older interface version - that,
	 * of course, also affects the "if" above).
	 */
	pIf->Destruct = rsconfDestruct;
	pIf->DebugPrint = rsconfDebugPrint;
	pIf->Load = load;

/* runtime/rsconf.c:1321 */
static rsRetVal
load(rsconf_t **cnf, uchar *confFile)
{
	...
	/* open the configuration file */
	r = cnfSetLexFile((char*)confFile);
	if(r == 0) {
		r = yyparse();
```

```
/* omzmq3.c:380 */
static rsRetVal newActInst(uchar __attribute__((unused)) *modName, struct nvlst __attribute__((unused)) *lst, void **ppModData, omodStringRequest_t **ppOMSR){  
	rsRetVal iRet = RS_RET_OK; instanceData *pData = ((void *)0); *ppOMSR = ((void *)0);
    struct cnfparamvals *pvals;
    int i;
CODESTARTnewActInst
    if ((pvals = nvlstGetParams(lst, &actpblk, NULL)) == NULL) {
        ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
    }

    CHKiRet(createInstance(&pData));
    setInstParamDefaults(pData);

    CODE_STD_STRING_REQUESTnewActInst(1)
    for (i = 0; i < actpblk.nParams; ++i) {
        if (!pvals[i].bUsed)
            continue;
        if (!strcmp(actpblk.descr[i].name, "description")) {
            pData->description = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
```

```
/* grammar/rainerscript.h:85 */
struct nvlst {
  struct nvlst *next;
  es_str_t *name; // ì´ê²Œ descriptionì´ ë˜ê³ ,
  struct svar val; // ì—¬ê¸° ì•ˆì— ìˆëŠ”ê²Œ tcp://ì´ ëœë‹¤.
  unsigned char bUsed;
  	/**< was this node used during config processing? If not, this
	 *   indicates an error. After all, the user specified a setting
	 *   that the software does not know.
	 */
};
```


```
/* contrib/omzmq3/README:23 */
/* descriptionì— %nì„ ë„£ìœ¼ë©´ format string bug ë°œìƒ ! */

Example Rsyslog.conf snippet (NOTE: v6 format):
-------------------------------------------------------------------------------
if $msg then {
    action(type="omzmq3", sockType="PUB", action="BIND", 
           description="tcp://*:7172)
}
-------------------------------------------------------------------------------
```


```
/* grammar.y:195 */
s_act:	  BEGIN_ACTION nvlst ENDOBJ	{ $$ = cnfstmtNewAct($2); } // ìœ„ ì˜ˆì œì˜ ê²½ìš°, keyì™€ value ìŒì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ nvlstë¡œ ë§Œë“  ê²ƒì´ $2ì´ë‹¤. 
```

```
/* rainerscript.c:3474 */
struct cnfstmt *
cnfstmtNewAct(struct nvlst *lst)
{
	struct cnfstmt* cnfstmt;
	char namebuf[256];
	rsRetVal localRet;
	if((cnfstmt = cnfstmtNew(S_ACT)) == NULL) 
		goto done;
	localRet = actionNewInst(lst, &cnfstmt->d.act);
```

```
/* action.c:1969 */
rsRetVal
actionNewInst(struct nvlst *lst, action_t **ppAction)
{
	struct cnfparamvals *paramvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	omodStringRequest_t *pOMSR;
	void *pModData;
	action_t *pAction;
	DEFiRet;

	paramvals = nvlstGetParams(lst, &pblk, NULL);
	if(paramvals == NULL) {
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	dbgprintf("action param blk after actionNewInst:\n");
	cnfparamsPrint(&pblk, paramvals);
	cnfModName = (uchar*)es_str2cstr(paramvals[cnfparamGetIdx(&pblk, ("type"))].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_OUT)) == NULL) {
		errmsg.LogError(0, RS_RET_MOD_UNKNOWN, "module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	CHKiRet(pMod->mod.om.newActInst(cnfModName, lst, &pModData, &pOMSR));
```

```
/* omzmq3.c:380 */
BEGINnewActInst
    struct cnfparamvals *pvals;
    int i;
CODESTARTnewActInst
    if ((pvals = nvlstGetParams(lst, &actpblk, NULL)) == NULL) {
        ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
    }

    CHKiRet(createInstance(&pData));
    setInstParamDefaults(pData);

    CODE_STD_STRING_REQUESTnewActInst(1)
    for (i = 0; i < actpblk.nParams; ++i) {
        if (!pvals[i].bUsed)
            continue;
        if (!strcmp(actpblk.descr[i].name, "description")) {
            pData->description = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
				// ë¬¸ì œê°€ ë˜ëŠ” descriptionì´ ì—¬ê¸°ì„œ ì„¤ì •ë¨.
```

ìœ„ ì˜ˆì œì— ëŒ€í•´ì„œëŠ” description = ì˜¤ë¥¸ìª½ì— ìˆëŠ” tcp:// ... ê°’ì´ pvals[i].val.d.estrì— ì €ì¥ëœë‹¤.


```
/* conrib/immq3/README.md:25 */
Example Rsyslog.conf snippet:
-------------------------------------------------------------------------------
module(load="imzmq3" ioThreads="1")
input(type="imzmq3" action="CONNECT" socktype="SUB" description="tcp://*:7172" subscribe="foo,bar")
```

imkmsgëŠ” ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë©”ì‹œì§€(ì»¤ë„ ë¡œê·¸)ë¥¼ ì…ë ¥ë°›ëŠ” rsyslog ëª¨ë“ˆì…ë‹ˆë‹¤. /proc/kmsg ë˜ëŠ” /dev/kmsgì—ì„œ ì»¤ë„ ë¡œê·¸ë¥¼ ì½ì–´ì™€ rsyslogë¡œ ì „ë‹¬í•©ë‹ˆë‹¤. 

rcv_loop()ëŠ” runInput()ì— ì˜í•´ í˜¸ì¶œë˜ë©°, 
runInput()ëŠ” input ëª¨ë“ˆì— ëŒ€í•œ mainí•¨ìˆ˜ë¡œì„œ input sourceë¡œ ë¶€í„° ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•˜ê³ , ë©”ì‹œì§€ íì— ì œì¶œí•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.

```c
static rsRetVal rcv_loop(thrdInfo_t* pThrd){
    size_t          n_items = 0;
    size_t          i;
    int             rv;
    zmq_pollitem_t* items = NULL;
    poller_data*    pollerData = NULL;
    struct lstn_s*  current;
    instanceConf_t* inst;
    DEFiRet;

    /* now add listeners. This actually creates the sockets, etc... */
    for (inst = runModConf->root; inst != NULL; inst=inst->next) {
        addListener(inst);
    }
    if (lcnfRoot == NULL) {
        errmsg.LogError(0, NO_ERRCODE, "imzmq3: no listeners were "
                        "started, input not activated.\n");
        ABORT_FINALIZE(RS_RET_NO_RUN);
    }

    /* count the # of items first */
    for(current=lcnfRoot;current!=NULL;current=current->next)
        n_items++;

    /* make arrays of pollitems, pollerdata so they are easy to delete later */
    
    /* create the poll items*/ 
    CHKmalloc(items = (zmq_pollitem_t*)MALLOC(sizeof(zmq_pollitem_t)*n_items));
    
    /* create poller data (stuff to pass into the zmq closure called when we get a message)*/
    CHKmalloc(pollerData = (poller_data*)MALLOC(sizeof(poller_data)*n_items));

    /* loop through and initialize the poll items and poller_data arrays...*/
    for(i=0, current = lcnfRoot; current != NULL; current = current->next, i++) {
        /* create the socket, update items.*/
        items[i].socket=current->sock;
        items[i].events = ZMQ_POLLIN;
        
        /* now update the poller_data for this item */
        pollerData[i].thread  = pThrd;
        pollerData[i].ruleset = current->pRuleset;
    }

    s_zloop = zloop_new();
    for(i=0; i<n_items; ++i) {
        
        rv = zloop_poller(s_zloop, &items[i], handlePoll, &pollerData[i]);
```

```c
/* contrib/imzmq3/imzmq3.c:566 */
static int handlePoll(zloop_t __attribute__((unused)) * loop, zmq_pollitem_t *poller, void* pd) {
    smsg_t* pMsg;
    poller_data* pollerData = (poller_data*)pd;

    char* buf = zstr_recv(poller->socket);
    if (msgConstruct(&pMsg) == RS_RET_OK) {
        MsgSetRawMsg(pMsg, buf, strlen(buf));
        MsgSetInputName(pMsg, s_namep);
        MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
        MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
        MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
        MsgSetMSGoffs(pMsg, 0);
        MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
        MsgSetRuleset(pMsg, pollerData->ruleset);
        pMsg->msgFlags = NEEDS_PARSING | PARSE_HOSTNAME;
        submitMsg2(pMsg);

/* tools/rsyslogd.c:975 */
rsRetVal
submitMsg2(smsg_t *pMsg)
{
	qqueue_t *pQueue;
	ruleset_t *pRuleset;
	DEFiRet;

	ISOBJ_TYPE_assert(pMsg, msg);

	pRuleset = MsgGetRuleset(pMsg);
	pQueue = (pRuleset == NULL) ? pMsgQueue : ruleset.GetRulesetQueue(pRuleset);

	/* if a plugin logs a message during shutdown, the queue may no longer exist */
	if(pQueue == NULL) {
		DBGPRINTF("submitMsg2() could not submit message - "
			  "queue does (no longer?) exist - ignored\n");
		FINALIZE;
	}

	qqueueEnqMsg(pQueue, pMsg->flowCtlType, pMsg);

/* runtime/queue.c:3011 */
rsRetVal
qqueueEnqMsg(qqueue_t *pThis, flowControl_t flowCtlType, smsg_t *pMsg)
{
	DEFiRet;
	int iCancelStateSave;
	ISOBJ_TYPE_assert(pThis, qqueue);

	const int isNonDirectQ = pThis->qType != QUEUETYPE_DIRECT;

	if(isNonDirectQ) {
		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &iCancelStateSave);
		d_pthread_mutex_lock(pThis->mut);
	}

	CHKiRet(doEnqSingleObj(pThis, flowCtlType, pMsg));

/* queueAdd()ê°€ ì‹¤ì§ˆì ìœ¼ë¡œ messageë¥¼ ë„£ëŠ” í•¨ìˆ˜ì´ê³ , queue ìƒì„± ì‹œ, queue íƒ€ì…ì— ë”°ë¼ì„œ add í•¨ìˆ˜ê°€ ë‹¬ë¼ì§(diskqueue, linkedqueue ...)
/* runtime/queue.c:2910 */
static rsRetVal
doEnqSingleObj(qqueue_t *pThis, flowControl_t flowCtlType, smsg_t *pMsg)
{
	DEFiRet;
	int err;
	struct timespec t;

	STATSCOUNTER_INC(pThis->ctrEnqueued, pThis->mutCtrEnqueued);
	/* first check if we need to discard this message (which will cause CHKiRet() to exit)
	 */
	CHKiRet(qqueueChkDiscardMsg(pThis, pThis->iQueueSize, pMsg));

	/* handle flow control
	 * There are two different flow control mechanisms: basic and advanced flow control.
	 * Basic flow control has always been implemented and protects the queue structures
	 * in that it makes sure no more data is enqueued than the queue is configured to
	 * support. Enhanced flow control is being added today. There are some sources which
	 * can easily be stopped, e.g. a file reader. This is the case because it is unlikely
	 * that blocking those sources will have negative effects (after all, the file is
	 * continued to be written). Other sources can somewhat be blocked (e.g. the kernel
	 * log reader or the local log stream reader): in general, nothing is lost if messages
	 * from these sources are not picked up immediately. HOWEVER, they can not block for
	 * an extended period of time, as this either causes message loss or - even worse - some
	 * other bad effects (e.g. unresponsive system in respect to the main system log socket).
	 * Finally, there are some (few) sources which can not be blocked at all. UDP syslog is
	 * a prime example. If a UDP message is not received, it is simply lost. So we can't
	 * do anything against UDP sockets that come in too fast. The core idea of advanced
	 * flow control is that we take into account the different natures of the sources and
	 * select flow control mechanisms that fit these needs. This also means, in the end
	 * result, that non-blockable sources like UDP syslog receive priority in the system.
	 * It's a side effect, but a good one ;) -- rgerhards, 2008-03-14
	 */
	if(flowCtlType == eFLOWCTL_FULL_DELAY) {
		while(pThis->iQueueSize >= pThis->iFullDlyMrk&& ! glbl.GetGlobalInputTermState()) {
			/* We have a problem during shutdown if we block eternally. In that
			 * case, the the input thread cannot be terminated. So we wake up
			 * from time to time to check for termination.
			 * TODO/v6(at earliest): check if we could signal the condition during
			 * shutdown. However, this requires new queue registries and thus is
			 * far to much change for a stable version (and I am still not sure it
			 * is worth the effort, given how seldom this situation occurs and how
			 * few resources the wakeups need). -- rgerhards, 2012-05-03
			 * In any case, this was the old code (if we do the TODO):
			 * pthread_cond_wait(&pThis->belowFullDlyWtrMrk, pThis->mut);
			 */
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: FullDelay mark reached for full delayable message "
				   "- blocking, queue size is %d.\n", pThis->iQueueSize);
			timeoutComp(&t, 1000);
			err = pthread_cond_timedwait(&pThis->belowLightDlyWtrMrk, pThis->mut, &t);
			if(err != 0 && err != ETIMEDOUT) {
				/* Something is really wrong now. Report to debug log and abort the
				 * wait. That keeps us running, even though we may lose messages.
				 */
				DBGOPRINT((obj_t*) pThis, "potential program bug: pthread_cond_timedwait()"
				          "/fulldelay returned %d\n", err);
				break;
				
			}
			DBGPRINTF("wti worker in full delay timed out, checking termination...\n");
		}
	} else if(flowCtlType == eFLOWCTL_LIGHT_DELAY && !glbl.GetGlobalInputTermState()) {
		if(pThis->iQueueSize >= pThis->iLightDlyMrk) {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: LightDelay mark reached for light "
			          "delayable message - blocking a bit.\n");
			timeoutComp(&t, 1000); /* 1000 millisconds = 1 second TODO: make configurable */
			err = pthread_cond_timedwait(&pThis->belowLightDlyWtrMrk, pThis->mut, &t);
			if(err != 0 && err != ETIMEDOUT) {
				/* Something is really wrong now. Report to debug log */
				DBGOPRINT((obj_t*) pThis, "potential program bug: pthread_cond_timedwait()"
				          "/lightdelay returned %d\n", err);
				
			}
		}
	}

	/* from our regular flow control settings, we are now ready to enqueue the object.
	 * However, we now need to do a check if the queue permits to add more data. If that
	 * is not the case, basic flow control enters the field, which means we wait for
	 * the queue to become ready or drop the new message. -- rgerhards, 2008-03-14
	 */
	while(   (pThis->iMaxQueueSize > 0 && pThis->iQueueSize >= pThis->iMaxQueueSize)
	      || ((pThis->qType == QUEUETYPE_DISK || pThis->bIsDA) && pThis->sizeOnDiskMax != 0
	      	  && pThis->tVars.disk.sizeOnDisk > pThis->sizeOnDiskMax)) {
		STATSCOUNTER_INC(pThis->ctrFull, pThis->mutCtrFull);
		if(pThis->toEnq == 0 || pThis->bEnqOnly) {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL - configured for immediate discarding QueueSize=%d "
				"MaxQueueSize=%d sizeOnDisk=%lld sizeOnDiskMax=%lld\n", pThis->iQueueSize, pThis->iMaxQueueSize,
				pThis->tVars.disk.sizeOnDisk, pThis->sizeOnDiskMax); 
			STATSCOUNTER_INC(pThis->ctrFDscrd, pThis->mutCtrFDscrd);
			msgDestruct(&pMsg);
			ABORT_FINALIZE(RS_RET_QUEUE_FULL);
		} else {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL - waiting %dms to drain.\n", pThis->toEnq);
			if(glbl.GetGlobalInputTermState()) {
				DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL, discard due to FORCE_TERM.\n");
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			}
			timeoutComp(&t, pThis->toEnq);
			if(pthread_cond_timedwait(&pThis->notFull, pThis->mut, &t) != 0) {
				DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: cond timeout, dropping message!\n");
				STATSCOUNTER_INC(pThis->ctrFDscrd, pThis->mutCtrFDscrd);
				msgDestruct(&pMsg);
				ABORT_FINALIZE(RS_RET_QUEUE_FULL);
			}
		dbgoprint((obj_t*) pThis, "doEnqSingleObject: wait solved queue full condition, enqueing\n");
		}
	}

	/* and finally enqueue the message */
	CHKiRet(qqueueAdd(pThis, pMsg));

// queue.c: 1069, static rsRetVal qqueueAdd(qqueue_t *pThis, smsg_t *pMsg)

// ì—¬ê¸°ì„œ ì–´ë–»ê²Œ ì—°ê²°í•´ì•¼í• ì§€ê°€ ë…¼ì˜í•  í¬ì¸íŠ¸ ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤.
// queueì— pConsumerê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, pConsumer í•¨ìˆ˜ì— queueì— ìˆë˜ ë©”ì‹œì§€ê°€ ì…ë ¥ë˜ì–´ ì²˜ë¦¬ëœë‹¤ëŠ” ê±¸ ê°€ì •í•˜ê³ , ë°”ë¡œ enqueueë¡œ ë„˜ì–´ê°€ë„ ë ì§€. ê·¸ë ‡ë‹¤ë©´ ì´ê±¸ ì–´ë–»ê²Œ ìë™í™”í•´ì•¼ í• ì§€...

// queue.c:195ì—ì„œ pWtië¥¼ ì—…ë°ì´íŠ¸ by DequeueForConsumer(..., pWti, ...)

/* runtime/queue.c:1402 */
rsRetVal qqueueConstruct(qqueue_t **ppThis, queueType_t qType, int iWorkerThreads,
		        int iMaxQueueSize, rsRetVal (*pConsumer)(void*, batch_t*, wti_t*))
{
	DEFiRet;
	qqueue_t *pThis;
	const uchar *const workDir = glblGetWorkDirRaw();

	ASSERT(ppThis != NULL);
	ASSERT(pConsumer != NULL);
	ASSERT(iWorkerThreads >= 0);

	CHKmalloc(pThis = (qqueue_t *)calloc(1, sizeof(qqueue_t))); // ì—¬ê¸°ì„œ pThisê°€ ì„¸íŒ…ë¨.

	/* we have an object, so let's fill the properties */
	objConstructSetObjInfo(pThis);

	if(workDir != NULL) {
		if((pThis->pszSpoolDir = ustrdup(workDir)) == NULL)
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		pThis->lenSpoolDir = ustrlen(pThis->pszSpoolDir);
	}
	/* set some water marks so that we have useful defaults if none are set specifically */
	pThis->iFullDlyMrk  = -1;
	pThis->iLightDlyMrk = -1;
	pThis->iMaxFileSize = 1024 * 1024; /* default is 1 MiB */
	pThis->iQueueSize = 0;
	pThis->nLogDeq = 0;
	pThis->useCryprov = 0;
	pThis->iMaxQueueSize = iMaxQueueSize;
	pThis->pConsumer = pConsumer;

/* action.c:509 */
rsRetVal
actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
{
	DEFiRet;
	uchar pszAName[64]; /* friendly name of our action */

	if(!strcmp((char*)modGetName(pThis->pMod), "builtin:omdiscard")) {
		/* discard actions will be optimized out */
		FINALIZE;
	}
	/* generate a friendly name for us action stats */
	if(pThis->pszName == NULL) {
		snprintf((char*) pszAName, sizeof(pszAName), "action %d", pThis->iActionNbr);
		pThis->pszName = ustrdup(pszAName);
	}

	/* cache transactional attribute */
	pThis->isTransactional = pThis->pMod->mod.om.supportsTX;
	if(pThis->isTransactional) {
		int i;
		for(i = 0 ; i < pThis->iNumTpls ; ++i) {
			if(pThis->peParamPassing[i] != ACT_STRING_PASSING) {
		}
	}


	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&pThis->statsobj));
	CHKiRet(statsobj.SetName(pThis->statsobj, pThis->pszName));
	CHKiRet(statsobj.SetOrigin(pThis->statsobj, (uchar*)"core.action"));

	STATSCOUNTER_INIT(pThis->ctrProcessed, pThis->mutCtrProcessed);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("processed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrProcessed));

	STATSCOUNTER_INIT(pThis->ctrFail, pThis->mutCtrFail);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("failed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrFail));

	STATSCOUNTER_INIT(pThis->ctrSuspend, pThis->mutCtrSuspend);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("suspended"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrSuspend));
	STATSCOUNTER_INIT(pThis->ctrSuspendDuration, pThis->mutCtrSuspendDuration);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("suspended.duration"),
		ctrType_IntCtr, 0, &pThis->ctrSuspendDuration));

	STATSCOUNTER_INIT(pThis->ctrResume, pThis->mutCtrResume);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("resumed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrResume));

	CHKiRet(statsobj.ConstructFinalize(pThis->statsobj));

	/* create our queue */

	/* generate a friendly name for the queue */
	snprintf((char*) pszAName, sizeof(pszAName), "%s queue",
		 pThis->pszName);

	/* now check if we can run the action in "firehose mode" during stage one of 
	 * its processing (that is before messages are enqueued into the action q).
	 * This is only possible if some features, which require strict sequence, are
	 * not used. Thankfully, that is usually the case. The benefit of firehose
	 * mode is much faster processing (and simpler code) -- rgerhards, 2010-06-08
	 */
	if(   pThis->iExecEveryNthOccur > 1
	   || pThis->iSecsExecOnceInterval
	  ) {
		DBGPRINTF("info: firehose mode disabled for action because "
		          "iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n",
			  pThis->iExecEveryNthOccur, pThis->iSecsExecOnceInterval);
		pThis->submitToActQ = doSubmitToActionQComplex;
	} else if(pThis->bWriteAllMarkMsgs) {
		/* full firehose submission mode, default case*/
		pThis->submitToActQ = doSubmitToActionQ;
	} else {
		/* nearly full-speed submission mode */
		pThis->submitToActQ = doSubmitToActionQNotAllMark;
	}

	/* create queue */
	/* action queues always (for now) have just one worker. This may change when
	 * we begin to implement an interface the enable output modules to request
	 * to be run on multiple threads. So far, this is forbidden by the interface
	 * spec. -- rgerhards, 2008-01-30
	 */
    /* rsRetVal qqueueConstruct(qqueue_t **ppThis, queueType_t qType, int iWorkerThreads,
		        int iMaxQueueSize, rsRetVal (*pConsumer)(void*, batch_t*, wti_t*)) */
	CHKiRet(qqueueConstruct(&pThis->pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
					processBatchMain));

	/*
		ì´ ì½”ë“œëŠ” qqueueConstruct í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬, í(queue) ìë£Œêµ¬ì¡°ë¥¼ ì´ˆê¸°í™”(ìƒì„±)í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤.

		ê° ì¸ìì˜ ì˜ë¯¸ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

		&pThis->pQueue : ìƒì„±ëœ í ê°ì²´ë¥¼ ì €ì¥í•  í¬ì¸í„°(íì˜ ì£¼ì†Œ)
		cs.ActionQueType : íì˜ íƒ€ì…(íê°€ ì–´ë–¤ ë™ì‘ì„ í•˜ëŠ”ì§€ ì§€ì •)
		1 : íì˜ ë™ì‘ ëª¨ë“œ ë˜ëŠ” í”Œë˜ê·¸(ì˜ˆ: ë™ê¸°/ë¹„ë™ê¸°, í™œì„±í™” ì—¬ë¶€ ë“±, êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¦„)
		cs.iActionQueueSize : íì˜ í¬ê¸°(íì— ì €ì¥í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ í•­ëª© ìˆ˜)
		processBatchMain : íì— ì €ì¥ëœ í•­ëª©ì„ ì²˜ë¦¬í•  í•¨ìˆ˜(ì½œë°± í•¨ìˆ˜)
	*/

/* action.c:1416 */
static rsRetVal
processBatchMain(void *__restrict__ const pVoid,
	batch_t *__restrict__ const pBatch,
	wti_t *__restrict__ const pWti)
{
	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
	int i;
	struct syslogTime ttNow;
	DEFiRet;

	wtiResetExecState(pWti, pBatch);
	/* indicate we have not yet read the date */
	ttNow.year = 0;

	for(i = 0 ; i < batchNumMsgs(pBatch) && !*pWti->pbShutdownImmediate ; ++i) {
		if(batchIsValidElem(pBatch, i)) {
			/* we do not check error state below, because aborting would be
			 * more harmful than continuing.
			 */
			processMsgMain(pAction, pWti, pBatch->pElem[i].pMsg, &ttNow);

/* action.c:1382 */
static rsRetVal
processMsgMain(action_t *__restrict__ const pAction,
	wti_t *__restrict__ const pWti,
	smsg_t *__restrict__ const pMsg,
	struct syslogTime *ttNow)
{
	DEFiRet;

	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));

	if(pAction->isTransactional) {
		pWti->actWrkrInfo[pAction->iActionNbr].pAction = pAction;
		DBGPRINTF("action '%s': is transactional - executing in commit phase\n", pAction->pszName);
		actionPrepare(pAction, pWti);
		iRet = getReturnCode(pAction, pWti);
		FINALIZE;
	}

	iRet = actionProcessMessage(pAction,
				    pWti->actWrkrInfo[pAction->iActionNbr].p.nontx.actParams,
				    pWti);

/* action.c:1171 */
static rsRetVal actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
{
	DEFiRet;

	CHKiRet(actionPrepare(pThis, pWti));
	if(pThis->pMod->mod.om.SetShutdownImmdtPtr != NULL)
		pThis->pMod->mod.om.SetShutdownImmdtPtr(pThis->pModData, pWti->pbShutdownImmediate);
	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
		CHKiRet(actionCallDoAction(pThis, actParams, pWti));

/* action.c:1128 */
static rsRetVal actionCallDoAction(action_t *__restrict__ const pThis, 	actWrkrIParams_t *__restrict__ onst iparams, wti_t *__restrict__ const pWti) {
	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	int i;
	DEFiRet;

	DBGPRINTF("entering actionCalldoAction(), state: %s, actionNbr %d\n",
		  getActStateName(pThis, pWti), pThis->iActionNbr);

	iRet = pThis->pMod->mod.om.doAction(param,
				            pWti->actWrkrInfo[pThis->iActionNbr].actWrkrData);


/* contrib/omzmq3/omzmq3.c:359 */
BEGINdoAction
	instanceData *pData = pWrkrData->pData;
CODESTARTdoAction
	pthread_mutex_lock(&mutDoAct);
	iRet = writeZMQ(ppString[0], pData);

/* contrib/omzmq3/omzmq3.c:268 */
rsRetVal writeZMQ(uchar* msg, instanceData* pData) {
	DEFiRet;

    /* initialize if necessary */
    if(NULL == pData->socket)
		CHKiRet(initZMQ(pData));

/* contrib/omzmq3/omzmq3.c:245 */
static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    if (NULL == s_context) {
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
    if (pData->action == ACTION_BIND) {
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
```

ì´ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ Ksign ëª¨ë¸ì— ì ìš©í•´ì„œ ê²°ê³¼ë¥¼ íƒì§€í•´ë³´ì•˜ë”ë‹ˆ ì •ìƒìœ¼ë¡œ ì˜ˆì¸¡í–ˆë‹¤.

---

#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 

1. **ë¶€ì ì ˆí•œ criterion**
   * ì´ ì·¨ì•½ì ì˜ ê²½ìš° criterionìœ¼ë¡œ `zsocket_connect`ì´ ì¡íˆì§€ ì•Šì•„ ì •ìƒìœ¼ë¡œ íŒë‹¨ëœ ê²ƒìœ¼ë¡œ ë³´ì„.

---

## ì·¨ì•½ì  ì„¸ë¶€ ì‚¬í•­

### â—ï¸ì·¨ì•½ ì½”ë“œ

#### Sink: `before_omzmq3.c:252`

```c
if(-1 == zsocket_connect(pData->socket, (char*)pData->description))
```

**ë¬¸ì œì **:
* `info->description`ì€ ì™¸ë¶€ ì„¤ì • íŒŒì¼ ë˜ëŠ” ì…ë ¥ì„ í†µí•´ ìœ ì…ë˜ëŠ” ì‚¬ìš©ì ì œì–´ ê°€ëŠ¥ ë¬¸ìì—´ì…ë‹ˆë‹¤.
* í•´ë‹¹ ê°’ì´ í¬ë§· ë¬¸ìì—´ ìë¦¬ì— ì§ì ‘ ë“¤ì–´ê°€ë¯€ë¡œ, `%s`, `%x` ë“±ì˜ í¬ë§· ì§€ì •ìê°€ í¬í•¨ë  ê²½ìš°
  í˜•ì‹ ë¬¸ìì—´ ì·¨ì•½ì (CWE-134) ë°œìƒ ê°€ëŠ¥

### âœ… ê°œì„  ì½”ë“œ

**íŒ¨ì¹˜ ìœ„ì¹˜**: `after_omzmq3.c:252`

```c
if(-1 == zsocket_connect(pData->socket, "%s", (char*)pData->description))
```

**ê°œì„  ë°©ë²•**:

* í¬ë§· ë¬¸ìì—´ì„ ê³ ì •ëœ `"%s"`ë¡œ ëª…ì‹œí•˜ì—¬ ì™¸ë¶€ ì…ë ¥ì´ í¬ë§·ìœ¼ë¡œ í•´ì„ë˜ì§€ ì•Šë„ë¡ ì¡°ì¹˜
* ì‚¬ìš©ì ì…ë ¥ì€ í¬ë§· ë¬¸ìì—´ì˜ ì¸ì(`"%s"`, `"%d"` ë“±)ì—ë§Œ ì „ë‹¬ë˜ë„ë¡ êµ¬ì„±í•´ì•¼ í•˜ë©°, **í¬ë§· ë¬¸ìì—´ ìì²´ë¡œ ì‚¬ìš©ë˜ì–´ì„œëŠ” ì•ˆ ë¨**
#### í¬ë§· ë¬¸ìì—´: `"%s"`, `"%d"`, `"%x"` ê°™ì€ ì¶œë ¥ í˜•ì‹ ëª…ë ¹ì´ ë“¤ì–´ìˆëŠ” ë¬¸ìì—´ë¡œ, `sprintf`ë¥˜ í•¨ìˆ˜ì˜ ë‘ ë²ˆì§¸ ì¸ìë¡œ ì“°ì´ëŠ” ë¬¸ìì—´
#### `printf`, `sprintf`, `fprintf` ê°™ì€ í•¨ìˆ˜ì˜ ë‘ ë²ˆì§¸ ì¸ìë¡œ `user_input`ì´ ë“¤ì–´ê°€ë©´ ì•ˆëœë‹¤ëŠ” ì˜ë¯¸

---

## íƒì§€ ê²°ê³¼
\* cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller)ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ ê´€ë ¨ ë°ì´í„°ë§Œ ì¶”ì¶œ
* ì—†ìŒ