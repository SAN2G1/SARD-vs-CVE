# üìÅ CVE-2017-12588

## üîç Ï∑®ÏïΩÏ†ê Í∞úÏöî

**üîó [Ïª§Î∞ã ÎßÅÌÅ¨](https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b)** | **üîó [CVE ÎßÅÌÅ¨](https://www.cvedetails.com/cve/CVE-2017-12588/)**  | **üîó [CWE ÎßÅÌÅ¨](https://cwe.mitre.org/data/definitions/134.html)**  


> rsyslog 8.28.0 Ïù¥Ï†Ñ Î≤ÑÏ†ÑÏùò `omzmq3` Î∞è `imzmq3` Î™®ÎìàÏóêÏÑúÎäî ÏÑ§Î™Ö(description) ÌïÑÎìúÍ∞Ä ÌòïÏãù Î¨∏ÏûêÏó¥Î°ú Ìï¥ÏÑùÎêòÎäî Î¨∏Ï†úÍ∞Ä Ï°¥Ïû¨Ìï©ÎãàÎã§.  
> Ïù¥Î°ú Ïù∏Ìï¥ Í≥µÍ≤©ÏûêÎäî Ìè¨Îß∑ Î¨∏ÏûêÏó¥ ÏßÄÏ†ïÏûêÎ•º Ìè¨Ìï®Ìïú ÏûÖÎ†•ÏùÑ ÌÜµÌï¥ **ÌòïÏãù Î¨∏ÏûêÏó¥ Ï∑®ÏïΩÏ†ê(CWE-134)**ÏùÑ Ïú†Î∞úÌï† Ïàò ÏûàÏúºÎ©∞, Ïù¥Îäî ÏÑúÎπÑÏä§ Í±∞Î∂Ä ÎòêÎäî Î©îÎ™®Î¶¨ Ï°∞ÏûëÍ≥º Í∞ôÏùÄ ÏòÅÌñ•ÏùÑ Ï¥àÎûòÌï† Ïàò ÏûàÏäµÎãàÎã§.

* **Source**: ÏÑ§Î™Ö Î¨∏ÏûêÏó¥(`info->description`) ‚Äì Ïô∏Î∂Ä ÏûÖÎ†•Ïóê ÏùòÌï¥ ÏÑ§Ï†ïÎê† Ïàò ÏûàÏùå
* **Ï∑®ÏïΩ Ï°∞Í±¥**: ÏÑ§Î™Ö(description) Î¨∏ÏûêÏó¥Ïóê Ìè¨Îß∑ Î¨∏ÏûêÏó¥ ÏßÄÏ†ïÏûê(`%s`, `%x` Îì±)Í∞Ä Ìè¨Ìï®Îêú Í≤ΩÏö∞, Ìï¥Îãπ Î¨∏ÏûêÏó¥Ïù¥ Ìè¨Îß∑ Î¨∏ÏûêÏó¥Î°ú ÏßÅÏ†ë ÏÇ¨Ïö©Îê®
* **Sink**: `zsocket_connect()`, `zsocket_bind()` ‚Äì ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú `printf` Í≥ÑÏó¥ Ìï®ÏàòÏóê format stringÏúºÎ°ú Ï†ÑÎã¨Îê®

---

## ÌÉêÏßÄ Í≤∞Í≥º ÏöîÏïΩ

| Ï¥ù Ïä¨ÎùºÏù¥Ïä§ Ïàò | Ï∑®ÏïΩÏúºÎ°ú ÌÉêÏßÄ | Ï†ïÏÉÅÏúºÎ°ú ÌÉêÏßÄ |
|----------------|----------------|----------------|
| 0Í∞ú           | 0Í∞ú            | 0Í∞ú           |

\* Sink(`zsocket_connect` Ìï®Ïàò) Í¥ÄÎ†® Ïä¨ÎùºÏù¥Ïä§Îäî Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå.

1. rsyslogdÍ∞Ä ÏãúÏûëÎêòÏñ¥ÏÑú conf ÌååÏùºÏùÑ ÏùΩÍ≥†,
2. newActInst Î™®Îìà Ìï®ÏàòÎ•º Ìò∏Ï∂úÌï¥ÏÑú pDataÏùò description Í¥ÄÎ†® ÌïÑÎìúÏóê Ìè¨Îß∑ ÏóêÎü¨ÏôÄ Í¥ÄÎ†®Îêú ÏïÖÏÑ± Ïä§Ìä∏ÎßÅÏùÑ ÏÑ§Ï†ïÌïòÍ≥†
3. doAction Î™®Îìà Ìï®ÏàòÎÇò, tryResume Î™®Îìà Ìï®ÏàòÍ∞Ä Î∂àÎ†∏ÏùÑ Îïå
4. zsocket_connectÎ•º Ìò∏Ï∂úÌï† ÎñÑ, description Ïä§Ìä∏ÎßÅÏùÑ Ìè¨Îß∑ Ïä§Ìä∏ÎßÅÏúºÎ°ú ÏÇ¨Ïö©Ìï¥ÏÑú Ï∑®ÏïΩÏ†êÏù¥ Î∞úÏÉùÌïúÎã§.

Ïä¨ÎùºÏù¥Ïä§Î•º ÎëêÍ∞úÎ•º ÌïôÏäµÏùÑ ÏãúÏºúÏïº ÌïúÎã§. Í∏∞Ï°¥ÏóêÎäî Ï∑®ÏïΩÏ†êÏùÑ ÌïòÎÇòÏùò Ï∑®ÏïΩÏ†êÏúºÎ°ú Ï†ïÏùòÌïòÍ≥†Ïûê ÌñàÏúºÎÇò, Í±∞Í∏∞Ïóê Ìï¥ÎãπÌïòÏßÄ ÏïäÎäî ÏÇ¨Î°ÄÎ°ú Î≥¥Ïù∏Îã§.

newActionInst ÌõÑÏóê doActionÏù¥ÎÇò tryResumeÏù¥ Ìò∏Ï∂úÎêúÎã§Îäî Î≥¥Ïû•Ïù¥ ÏóÜÍ∏∞ ÎïåÎ¨∏Ïóê

Ïù¥ CVE Ï∑®ÏïΩÏ†êÏùÑ Ïú†Î∞úÌïòÎäî ÏΩîÎìú(sink:contrib/omzmq3/omzmq3.c:245)Îäî ÏïÑÎûòÏôÄ Í∞ôÎã§.
```
static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    if (NULL == s_context) {
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
    if (pData->action == ACTION_BIND) {
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
```
Ïù¥ ÏΩîÎìúÏóêÏÑú Ksign Ïä¨ÎùºÏù¥ÏÑú ÎèÑÍµ¨Í∞Ä Ï∂îÏ∂úÌñàÏñ¥Ïïº ÌïòÎäî Ïä¨ÎùºÏù¥Ïä§Î•º ÏßÅÏ†ë ÏûëÏÑ±Ìï¥Î≥¥Î©¥ Îã§ÏùåÍ≥º Í∞ôÎã§.



```
// ÏïÑÎûòÏôÄ Í∞ôÏù¥ ,Í∞Ä ÏóÜÎäîÍ≤å ÎßûÎã§.
/* descriptionÏóê %nÏùÑ ÎÑ£ÏúºÎ©¥ format string bug Î∞úÏÉù ! */
// https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/deployment_guide/s1-basic_configuration_of_rsyslog
if $programname == 'prog1' then {
   action(type="omfile" file="/var/log/prog1.log")
   if $msg contains 'test' then
     action(type="omfile" file="/var/log/prog1test.log")
   else
     action(type="omfile" file="/var/log/prog1notest.log")
}

```


```c
/* rsyslogd.c:1407 */
rsconf_t *ourConf = NULL;
uchar *ConfFile = (uchar*) "/etc/rsyslog.conf";

static void
initAll(int argc, char **argv)
{
	...
	localRet = rsconf.Load(&ourConf, ConfFile);

/* runtime/rsconf.c:1391 */
BEGINobjQueryInterface(rsconf)
CODESTARTobjQueryInterface(rsconf)
	if(pIf->ifVersion != rsconfCURR_IF_VERSION) { /* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}

	/* ok, we have the right interface, so let's fill it
	 * Please note that we may also do some backwards-compatibility
	 * work here (if we can support an older interface version - that,
	 * of course, also affects the "if" above).
	 */
	pIf->Destruct = rsconfDestruct;
	pIf->DebugPrint = rsconfDebugPrint;
	pIf->Load = load;

/* runtime/rsconf.c:1321 */
static rsRetVal
load(rsconf_t **cnf, uchar *confFile)
{
	...
	/* open the configuration file */
	r = cnfSetLexFile((char*)confFile);
	if(r == 0) {
		r = yyparse();
```

```
/* omzmq3.c:380 */
static rsRetVal newActInst(uchar __attribute__((unused)) *modName, struct nvlst __attribute__((unused)) *lst, void **ppModData, omodStringRequest_t **ppOMSR){  
	rsRetVal iRet = RS_RET_OK; instanceData *pData = ((void *)0); *ppOMSR = ((void *)0);
    struct cnfparamvals *pvals;
    int i;
CODESTARTnewActInst
    if ((pvals = nvlstGetParams(lst, &actpblk, NULL)) == NULL) {
        ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
    }

    CHKiRet(createInstance(&pData));
    setInstParamDefaults(pData);

    CODE_STD_STRING_REQUESTnewActInst(1)
    for (i = 0; i < actpblk.nParams; ++i) {
        if (!pvals[i].bUsed)
            continue;
        if (!strcmp(actpblk.descr[i].name, "description")) {
            pData->description = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
```

```
/* grammar/rainerscript.h:85 */
struct nvlst {
  struct nvlst *next;
  es_str_t *name; // Ïù¥Í≤å descriptionÏù¥ ÎêòÍ≥†,
  struct svar val; // Ïó¨Í∏∞ ÏïàÏóê ÏûàÎäîÍ≤å tcp://Ïù¥ ÎêúÎã§.
  unsigned char bUsed;
  	/**< was this node used during config processing? If not, this
	 *   indicates an error. After all, the user specified a setting
	 *   that the software does not know.
	 */
};
```


```
/* contrib/omzmq3/README:23 */
/* descriptionÏóê %nÏùÑ ÎÑ£ÏúºÎ©¥ format string bug Î∞úÏÉù ! */

Example Rsyslog.conf snippet (NOTE: v6 format):
-------------------------------------------------------------------------------
if $msg then {
    action(type="omzmq3", sockType="PUB", action="BIND", 
           description="tcp://*:7172)
}
-------------------------------------------------------------------------------
```


```
/* grammar.y:195 */
s_act:	  BEGIN_ACTION nvlst ENDOBJ	{ $$ = cnfstmtNewAct($2); } // ÏúÑ ÏòàÏ†úÏùò Í≤ΩÏö∞, keyÏôÄ value ÏåçÏùò Î¶¨Ïä§Ìä∏Î•º nvlstÎ°ú ÎßåÎì† Í≤ÉÏù¥ $2Ïù¥Îã§. 
```

```
/* rainerscript.c:3474 */
struct cnfstmt *
cnfstmtNewAct(struct nvlst *lst)
{
	struct cnfstmt* cnfstmt;
	char namebuf[256];
	rsRetVal localRet;
	if((cnfstmt = cnfstmtNew(S_ACT)) == NULL) 
		goto done;
	localRet = actionNewInst(lst, &cnfstmt->d.act);
```

```
/* action.c:1969 */
rsRetVal
actionNewInst(struct nvlst *lst, action_t **ppAction)
{
	struct cnfparamvals *paramvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	omodStringRequest_t *pOMSR;
	void *pModData;
	action_t *pAction;
	DEFiRet;

	paramvals = nvlstGetParams(lst, &pblk, NULL);
	if(paramvals == NULL) {
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	dbgprintf("action param blk after actionNewInst:\n");
	cnfparamsPrint(&pblk, paramvals);
	cnfModName = (uchar*)es_str2cstr(paramvals[cnfparamGetIdx(&pblk, ("type"))].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_OUT)) == NULL) {
		errmsg.LogError(0, RS_RET_MOD_UNKNOWN, "module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	CHKiRet(pMod->mod.om.newActInst(cnfModName, lst, &pModData, &pOMSR));
```

```
/* omzmq3.c:380 */
BEGINnewActInst
    struct cnfparamvals *pvals;
    int i;
CODESTARTnewActInst
    if ((pvals = nvlstGetParams(lst, &actpblk, NULL)) == NULL) {
        ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
    }

    CHKiRet(createInstance(&pData));
    setInstParamDefaults(pData);

    CODE_STD_STRING_REQUESTnewActInst(1)
    for (i = 0; i < actpblk.nParams; ++i) {
        if (!pvals[i].bUsed)
            continue;
        if (!strcmp(actpblk.descr[i].name, "description")) {
            pData->description = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
				// Î¨∏Ï†úÍ∞Ä ÎêòÎäî descriptionÏù¥ Ïó¨Í∏∞ÏÑú ÏÑ§Ï†ïÎê®.
```

ÏúÑ ÏòàÏ†úÏóê ÎåÄÌï¥ÏÑúÎäî description = Ïò§Î•∏Ï™ΩÏóê ÏûàÎäî tcp:// ... Í∞íÏù¥ pvals[i].val.d.estrÏóê Ï†ÄÏû•ÎêúÎã§.


```
/* conrib/immq3/README.md:25 */
Example Rsyslog.conf snippet:
-------------------------------------------------------------------------------
module(load="imzmq3" ioThreads="1")
input(type="imzmq3" action="CONNECT" socktype="SUB" description="tcp://*:7172" subscribe="foo,bar")
```

imkmsgÎäî Î¶¨ÎàÖÏä§ Ïª§ÎÑê Î©îÏãúÏßÄ(Ïª§ÎÑê Î°úÍ∑∏)Î•º ÏûÖÎ†•Î∞õÎäî rsyslog Î™®ÎìàÏûÖÎãàÎã§. /proc/kmsg ÎòêÎäî /dev/kmsgÏóêÏÑú Ïª§ÎÑê Î°úÍ∑∏Î•º ÏùΩÏñ¥ÏôÄ rsyslogÎ°ú Ï†ÑÎã¨Ìï©ÎãàÎã§. 

rcv_loop()Îäî runInput()Ïóê ÏùòÌï¥ Ìò∏Ï∂úÎêòÎ©∞, 
runInput()Îäî input Î™®ÎìàÏóê ÎåÄÌïú mainÌï®ÏàòÎ°úÏÑú input sourceÎ°ú Î∂ÄÌÑ∞ Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌïòÍ≥†, Î©îÏãúÏßÄ ÌÅêÏóê Ï†úÏ∂úÌïòÎäîÎç∞ ÏÇ¨Ïö©ÎêúÎã§.

```c
static rsRetVal rcv_loop(thrdInfo_t* pThrd){
    size_t          n_items = 0;
    size_t          i;
    int             rv;
    zmq_pollitem_t* items = NULL;
    poller_data*    pollerData = NULL;
    struct lstn_s*  current;
    instanceConf_t* inst;
    DEFiRet;

    /* now add listeners. This actually creates the sockets, etc... */
    for (inst = runModConf->root; inst != NULL; inst=inst->next) {
        addListener(inst);
    }
    if (lcnfRoot == NULL) {
        errmsg.LogError(0, NO_ERRCODE, "imzmq3: no listeners were "
                        "started, input not activated.\n");
        ABORT_FINALIZE(RS_RET_NO_RUN);
    }

    /* count the # of items first */
    for(current=lcnfRoot;current!=NULL;current=current->next)
        n_items++;

    /* make arrays of pollitems, pollerdata so they are easy to delete later */
    
    /* create the poll items*/ 
    CHKmalloc(items = (zmq_pollitem_t*)MALLOC(sizeof(zmq_pollitem_t)*n_items));
    
    /* create poller data (stuff to pass into the zmq closure called when we get a message)*/
    CHKmalloc(pollerData = (poller_data*)MALLOC(sizeof(poller_data)*n_items));

    /* loop through and initialize the poll items and poller_data arrays...*/
    for(i=0, current = lcnfRoot; current != NULL; current = current->next, i++) {
        /* create the socket, update items.*/
        items[i].socket=current->sock;
        items[i].events = ZMQ_POLLIN;
        
        /* now update the poller_data for this item */
        pollerData[i].thread  = pThrd;
        pollerData[i].ruleset = current->pRuleset;
    }

    s_zloop = zloop_new();
    for(i=0; i<n_items; ++i) {
        
        rv = zloop_poller(s_zloop, &items[i], handlePoll, &pollerData[i]);
```

```c
/* contrib/imzmq3/imzmq3.c:566 */
static int handlePoll(zloop_t __attribute__((unused)) * loop, zmq_pollitem_t *poller, void* pd) {
    smsg_t* pMsg;
    poller_data* pollerData = (poller_data*)pd;

    char* buf = zstr_recv(poller->socket);
    if (msgConstruct(&pMsg) == RS_RET_OK) {
        MsgSetRawMsg(pMsg, buf, strlen(buf));
        MsgSetInputName(pMsg, s_namep);
        MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
        MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
        MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
        MsgSetMSGoffs(pMsg, 0);
        MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
        MsgSetRuleset(pMsg, pollerData->ruleset);
        pMsg->msgFlags = NEEDS_PARSING | PARSE_HOSTNAME;
        submitMsg2(pMsg);

/* tools/rsyslogd.c:975 */
rsRetVal
submitMsg2(smsg_t *pMsg)
{
	qqueue_t *pQueue;
	ruleset_t *pRuleset;
	DEFiRet;

	ISOBJ_TYPE_assert(pMsg, msg);

	pRuleset = MsgGetRuleset(pMsg);
	pQueue = (pRuleset == NULL) ? pMsgQueue : ruleset.GetRulesetQueue(pRuleset);

	/* if a plugin logs a message during shutdown, the queue may no longer exist */
	if(pQueue == NULL) {
		DBGPRINTF("submitMsg2() could not submit message - "
			  "queue does (no longer?) exist - ignored\n");
		FINALIZE;
	}

	qqueueEnqMsg(pQueue, pMsg->flowCtlType, pMsg);

/* runtime/queue.c:3011 */
rsRetVal
qqueueEnqMsg(qqueue_t *pThis, flowControl_t flowCtlType, smsg_t *pMsg)
{
	DEFiRet;
	int iCancelStateSave;
	ISOBJ_TYPE_assert(pThis, qqueue);

	const int isNonDirectQ = pThis->qType != QUEUETYPE_DIRECT;

	if(isNonDirectQ) {
		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &iCancelStateSave);
		d_pthread_mutex_lock(pThis->mut);
	}

	CHKiRet(doEnqSingleObj(pThis, flowCtlType, pMsg));

/* queueAdd()Í∞Ä Ïã§ÏßàÏ†ÅÏúºÎ°ú messageÎ•º ÎÑ£Îäî Ìï®ÏàòÏù¥Í≥†, queue ÏÉùÏÑ± Ïãú, queue ÌÉÄÏûÖÏóê Îî∞ÎùºÏÑú add Ìï®ÏàòÍ∞Ä Îã¨ÎùºÏßê(diskqueue, linkedqueue ...)
/* runtime/queue.c:2910 */
static rsRetVal
doEnqSingleObj(qqueue_t *pThis, flowControl_t flowCtlType, smsg_t *pMsg)
{
	DEFiRet;
	int err;
	struct timespec t;

	STATSCOUNTER_INC(pThis->ctrEnqueued, pThis->mutCtrEnqueued);
	/* first check if we need to discard this message (which will cause CHKiRet() to exit)
	 */
	CHKiRet(qqueueChkDiscardMsg(pThis, pThis->iQueueSize, pMsg));

	/* handle flow control
	 * There are two different flow control mechanisms: basic and advanced flow control.
	 * Basic flow control has always been implemented and protects the queue structures
	 * in that it makes sure no more data is enqueued than the queue is configured to
	 * support. Enhanced flow control is being added today. There are some sources which
	 * can easily be stopped, e.g. a file reader. This is the case because it is unlikely
	 * that blocking those sources will have negative effects (after all, the file is
	 * continued to be written). Other sources can somewhat be blocked (e.g. the kernel
	 * log reader or the local log stream reader): in general, nothing is lost if messages
	 * from these sources are not picked up immediately. HOWEVER, they can not block for
	 * an extended period of time, as this either causes message loss or - even worse - some
	 * other bad effects (e.g. unresponsive system in respect to the main system log socket).
	 * Finally, there are some (few) sources which can not be blocked at all. UDP syslog is
	 * a prime example. If a UDP message is not received, it is simply lost. So we can't
	 * do anything against UDP sockets that come in too fast. The core idea of advanced
	 * flow control is that we take into account the different natures of the sources and
	 * select flow control mechanisms that fit these needs. This also means, in the end
	 * result, that non-blockable sources like UDP syslog receive priority in the system.
	 * It's a side effect, but a good one ;) -- rgerhards, 2008-03-14
	 */
	if(flowCtlType == eFLOWCTL_FULL_DELAY) {
		while(pThis->iQueueSize >= pThis->iFullDlyMrk&& ! glbl.GetGlobalInputTermState()) {
			/* We have a problem during shutdown if we block eternally. In that
			 * case, the the input thread cannot be terminated. So we wake up
			 * from time to time to check for termination.
			 * TODO/v6(at earliest): check if we could signal the condition during
			 * shutdown. However, this requires new queue registries and thus is
			 * far to much change for a stable version (and I am still not sure it
			 * is worth the effort, given how seldom this situation occurs and how
			 * few resources the wakeups need). -- rgerhards, 2012-05-03
			 * In any case, this was the old code (if we do the TODO):
			 * pthread_cond_wait(&pThis->belowFullDlyWtrMrk, pThis->mut);
			 */
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: FullDelay mark reached for full delayable message "
				   "- blocking, queue size is %d.\n", pThis->iQueueSize);
			timeoutComp(&t, 1000);
			err = pthread_cond_timedwait(&pThis->belowLightDlyWtrMrk, pThis->mut, &t);
			if(err != 0 && err != ETIMEDOUT) {
				/* Something is really wrong now. Report to debug log and abort the
				 * wait. That keeps us running, even though we may lose messages.
				 */
				DBGOPRINT((obj_t*) pThis, "potential program bug: pthread_cond_timedwait()"
				          "/fulldelay returned %d\n", err);
				break;
				
			}
			DBGPRINTF("wti worker in full delay timed out, checking termination...\n");
		}
	} else if(flowCtlType == eFLOWCTL_LIGHT_DELAY && !glbl.GetGlobalInputTermState()) {
		if(pThis->iQueueSize >= pThis->iLightDlyMrk) {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: LightDelay mark reached for light "
			          "delayable message - blocking a bit.\n");
			timeoutComp(&t, 1000); /* 1000 millisconds = 1 second TODO: make configurable */
			err = pthread_cond_timedwait(&pThis->belowLightDlyWtrMrk, pThis->mut, &t);
			if(err != 0 && err != ETIMEDOUT) {
				/* Something is really wrong now. Report to debug log */
				DBGOPRINT((obj_t*) pThis, "potential program bug: pthread_cond_timedwait()"
				          "/lightdelay returned %d\n", err);
				
			}
		}
	}

	/* from our regular flow control settings, we are now ready to enqueue the object.
	 * However, we now need to do a check if the queue permits to add more data. If that
	 * is not the case, basic flow control enters the field, which means we wait for
	 * the queue to become ready or drop the new message. -- rgerhards, 2008-03-14
	 */
	while(   (pThis->iMaxQueueSize > 0 && pThis->iQueueSize >= pThis->iMaxQueueSize)
	      || ((pThis->qType == QUEUETYPE_DISK || pThis->bIsDA) && pThis->sizeOnDiskMax != 0
	      	  && pThis->tVars.disk.sizeOnDisk > pThis->sizeOnDiskMax)) {
		STATSCOUNTER_INC(pThis->ctrFull, pThis->mutCtrFull);
		if(pThis->toEnq == 0 || pThis->bEnqOnly) {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL - configured for immediate discarding QueueSize=%d "
				"MaxQueueSize=%d sizeOnDisk=%lld sizeOnDiskMax=%lld\n", pThis->iQueueSize, pThis->iMaxQueueSize,
				pThis->tVars.disk.sizeOnDisk, pThis->sizeOnDiskMax); 
			STATSCOUNTER_INC(pThis->ctrFDscrd, pThis->mutCtrFDscrd);
			msgDestruct(&pMsg);
			ABORT_FINALIZE(RS_RET_QUEUE_FULL);
		} else {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL - waiting %dms to drain.\n", pThis->toEnq);
			if(glbl.GetGlobalInputTermState()) {
				DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL, discard due to FORCE_TERM.\n");
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			}
			timeoutComp(&t, pThis->toEnq);
			if(pthread_cond_timedwait(&pThis->notFull, pThis->mut, &t) != 0) {
				DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: cond timeout, dropping message!\n");
				STATSCOUNTER_INC(pThis->ctrFDscrd, pThis->mutCtrFDscrd);
				msgDestruct(&pMsg);
				ABORT_FINALIZE(RS_RET_QUEUE_FULL);
			}
		dbgoprint((obj_t*) pThis, "doEnqSingleObject: wait solved queue full condition, enqueing\n");
		}
	}

	/* and finally enqueue the message */
	CHKiRet(qqueueAdd(pThis, pMsg));

// queue.c: 1069, static rsRetVal qqueueAdd(qqueue_t *pThis, smsg_t *pMsg)

// Ïó¨Í∏∞ÏÑú Ïñ¥ÎñªÍ≤å Ïó∞Í≤∞Ìï¥ÏïºÌï†ÏßÄÍ∞Ä ÎÖºÏùòÌï† Ìè¨Ïù∏Ìä∏ Ïù∏ Í≤É Í∞ôÏäµÎãàÎã§.
// queueÏóê pConsumerÍ∞Ä Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú, pConsumer Ìï®ÏàòÏóê queueÏóê ÏûàÎçò Î©îÏãúÏßÄÍ∞Ä ÏûÖÎ†•ÎêòÏñ¥ Ï≤òÎ¶¨ÎêúÎã§Îäî Í±∏ Í∞ÄÏ†ïÌïòÍ≥†, Î∞îÎ°ú enqueueÎ°ú ÎÑòÏñ¥Í∞ÄÎèÑ Îê†ÏßÄ. Í∑∏Î†áÎã§Î©¥ Ïù¥Í±∏ Ïñ¥ÎñªÍ≤å ÏûêÎèôÌôîÌï¥Ïïº Ìï†ÏßÄ...

// queue.c:195ÏóêÏÑú pWtiÎ•º ÏóÖÎç∞Ïù¥Ìä∏ by DequeueForConsumer(..., pWti, ...)

/* runtime/queue.c:1402 */
rsRetVal qqueueConstruct(qqueue_t **ppThis, queueType_t qType, int iWorkerThreads,
		        int iMaxQueueSize, rsRetVal (*pConsumer)(void*, batch_t*, wti_t*))
{
	DEFiRet;
	qqueue_t *pThis;
	const uchar *const workDir = glblGetWorkDirRaw();

	ASSERT(ppThis != NULL);
	ASSERT(pConsumer != NULL);
	ASSERT(iWorkerThreads >= 0);

	CHKmalloc(pThis = (qqueue_t *)calloc(1, sizeof(qqueue_t))); // Ïó¨Í∏∞ÏÑú pThisÍ∞Ä ÏÑ∏ÌåÖÎê®.

	/* we have an object, so let's fill the properties */
	objConstructSetObjInfo(pThis);

	if(workDir != NULL) {
		if((pThis->pszSpoolDir = ustrdup(workDir)) == NULL)
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		pThis->lenSpoolDir = ustrlen(pThis->pszSpoolDir);
	}
	/* set some water marks so that we have useful defaults if none are set specifically */
	pThis->iFullDlyMrk  = -1;
	pThis->iLightDlyMrk = -1;
	pThis->iMaxFileSize = 1024 * 1024; /* default is 1 MiB */
	pThis->iQueueSize = 0;
	pThis->nLogDeq = 0;
	pThis->useCryprov = 0;
	pThis->iMaxQueueSize = iMaxQueueSize;
	pThis->pConsumer = pConsumer;

/* action.c:509 */
rsRetVal
actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
{
	DEFiRet;
	uchar pszAName[64]; /* friendly name of our action */

	if(!strcmp((char*)modGetName(pThis->pMod), "builtin:omdiscard")) {
		/* discard actions will be optimized out */
		FINALIZE;
	}
	/* generate a friendly name for us action stats */
	if(pThis->pszName == NULL) {
		snprintf((char*) pszAName, sizeof(pszAName), "action %d", pThis->iActionNbr);
		pThis->pszName = ustrdup(pszAName);
	}

	/* cache transactional attribute */
	pThis->isTransactional = pThis->pMod->mod.om.supportsTX;
	if(pThis->isTransactional) {
		int i;
		for(i = 0 ; i < pThis->iNumTpls ; ++i) {
			if(pThis->peParamPassing[i] != ACT_STRING_PASSING) {
		}
	}


	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&pThis->statsobj));
	CHKiRet(statsobj.SetName(pThis->statsobj, pThis->pszName));
	CHKiRet(statsobj.SetOrigin(pThis->statsobj, (uchar*)"core.action"));

	STATSCOUNTER_INIT(pThis->ctrProcessed, pThis->mutCtrProcessed);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("processed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrProcessed));

	STATSCOUNTER_INIT(pThis->ctrFail, pThis->mutCtrFail);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("failed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrFail));

	STATSCOUNTER_INIT(pThis->ctrSuspend, pThis->mutCtrSuspend);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("suspended"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrSuspend));
	STATSCOUNTER_INIT(pThis->ctrSuspendDuration, pThis->mutCtrSuspendDuration);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("suspended.duration"),
		ctrType_IntCtr, 0, &pThis->ctrSuspendDuration));

	STATSCOUNTER_INIT(pThis->ctrResume, pThis->mutCtrResume);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("resumed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrResume));

	CHKiRet(statsobj.ConstructFinalize(pThis->statsobj));

	/* create our queue */

	/* generate a friendly name for the queue */
	snprintf((char*) pszAName, sizeof(pszAName), "%s queue",
		 pThis->pszName);

	/* now check if we can run the action in "firehose mode" during stage one of 
	 * its processing (that is before messages are enqueued into the action q).
	 * This is only possible if some features, which require strict sequence, are
	 * not used. Thankfully, that is usually the case. The benefit of firehose
	 * mode is much faster processing (and simpler code) -- rgerhards, 2010-06-08
	 */
	if(   pThis->iExecEveryNthOccur > 1
	   || pThis->iSecsExecOnceInterval
	  ) {
		DBGPRINTF("info: firehose mode disabled for action because "
		          "iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n",
			  pThis->iExecEveryNthOccur, pThis->iSecsExecOnceInterval);
		pThis->submitToActQ = doSubmitToActionQComplex;
	} else if(pThis->bWriteAllMarkMsgs) {
		/* full firehose submission mode, default case*/
		pThis->submitToActQ = doSubmitToActionQ;
	} else {
		/* nearly full-speed submission mode */
		pThis->submitToActQ = doSubmitToActionQNotAllMark;
	}

	/* create queue */
	/* action queues always (for now) have just one worker. This may change when
	 * we begin to implement an interface the enable output modules to request
	 * to be run on multiple threads. So far, this is forbidden by the interface
	 * spec. -- rgerhards, 2008-01-30
	 */
    /* rsRetVal qqueueConstruct(qqueue_t **ppThis, queueType_t qType, int iWorkerThreads,
		        int iMaxQueueSize, rsRetVal (*pConsumer)(void*, batch_t*, wti_t*)) */
	CHKiRet(qqueueConstruct(&pThis->pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
					processBatchMain));

	/*
		Ïù¥ ÏΩîÎìúÎäî qqueueConstruct Ìï®ÏàòÎ•º Ìò∏Ï∂úÌïòÏó¨, ÌÅê(queue) ÏûêÎ£åÍµ¨Ï°∞Î•º Ï¥àÍ∏∞Ìôî(ÏÉùÏÑ±)ÌïòÎäî Î∂ÄÎ∂ÑÏûÖÎãàÎã§.

		Í∞Å Ïù∏ÏûêÏùò ÏùòÎØ∏Îäî Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§:

		&pThis->pQueue : ÏÉùÏÑ±Îêú ÌÅê Í∞ùÏ≤¥Î•º Ï†ÄÏû•Ìï† Ìè¨Ïù∏ÌÑ∞(ÌÅêÏùò Ï£ºÏÜå)
		cs.ActionQueType : ÌÅêÏùò ÌÉÄÏûÖ(ÌÅêÍ∞Ä Ïñ¥Îñ§ ÎèôÏûëÏùÑ ÌïòÎäîÏßÄ ÏßÄÏ†ï)
		1 : ÌÅêÏùò ÎèôÏûë Î™®Îìú ÎòêÎäî ÌîåÎûòÍ∑∏(Ïòà: ÎèôÍ∏∞/ÎπÑÎèôÍ∏∞, ÌôúÏÑ±Ìôî Ïó¨Î∂Ä Îì±, Íµ¨ÌòÑÏóê Îî∞Îùº Îã§Î¶Ñ)
		cs.iActionQueueSize : ÌÅêÏùò ÌÅ¨Í∏∞(ÌÅêÏóê Ï†ÄÏû•Ìï† Ïàò ÏûàÎäî ÏµúÎåÄ Ìï≠Î™© Ïàò)
		processBatchMain : ÌÅêÏóê Ï†ÄÏû•Îêú Ìï≠Î™©ÏùÑ Ï≤òÎ¶¨Ìï† Ìï®Ïàò(ÏΩúÎ∞± Ìï®Ïàò)
	*/

/* action.c:1416 */
static rsRetVal
processBatchMain(void *__restrict__ const pVoid,
	batch_t *__restrict__ const pBatch,
	wti_t *__restrict__ const pWti)
{
	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
	int i;
	struct syslogTime ttNow;
	DEFiRet;

	wtiResetExecState(pWti, pBatch);
	/* indicate we have not yet read the date */
	ttNow.year = 0;

	for(i = 0 ; i < batchNumMsgs(pBatch) && !*pWti->pbShutdownImmediate ; ++i) {
		if(batchIsValidElem(pBatch, i)) {
			/* we do not check error state below, because aborting would be
			 * more harmful than continuing.
			 */
			processMsgMain(pAction, pWti, pBatch->pElem[i].pMsg, &ttNow);

/* action.c:1382 */
static rsRetVal
processMsgMain(action_t *__restrict__ const pAction,
	wti_t *__restrict__ const pWti,
	smsg_t *__restrict__ const pMsg,
	struct syslogTime *ttNow)
{
	DEFiRet;

	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));

	if(pAction->isTransactional) {
		pWti->actWrkrInfo[pAction->iActionNbr].pAction = pAction;
		DBGPRINTF("action '%s': is transactional - executing in commit phase\n", pAction->pszName);
		actionPrepare(pAction, pWti);
		iRet = getReturnCode(pAction, pWti);
		FINALIZE;
	}

	iRet = actionProcessMessage(pAction,
				    pWti->actWrkrInfo[pAction->iActionNbr].p.nontx.actParams,
				    pWti);

/* action.c:1171 */
static rsRetVal actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
{
	DEFiRet;

	CHKiRet(actionPrepare(pThis, pWti));
	if(pThis->pMod->mod.om.SetShutdownImmdtPtr != NULL)
		pThis->pMod->mod.om.SetShutdownImmdtPtr(pThis->pModData, pWti->pbShutdownImmediate);
	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
		CHKiRet(actionCallDoAction(pThis, actParams, pWti));

/* action.c:1128 */
static rsRetVal actionCallDoAction(action_t *__restrict__ const pThis, 	actWrkrIParams_t *__restrict__ onst iparams, wti_t *__restrict__ const pWti) {
	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	int i;
	DEFiRet;

	DBGPRINTF("entering actionCalldoAction(), state: %s, actionNbr %d\n",
		  getActStateName(pThis, pWti), pThis->iActionNbr);

	iRet = pThis->pMod->mod.om.doAction(param,
				            pWti->actWrkrInfo[pThis->iActionNbr].actWrkrData);


/* contrib/omzmq3/omzmq3.c:359 */
BEGINdoAction
	instanceData *pData = pWrkrData->pData;
CODESTARTdoAction
	pthread_mutex_lock(&mutDoAct);
	iRet = writeZMQ(ppString[0], pData);

/* contrib/omzmq3/omzmq3.c:268 */
rsRetVal writeZMQ(uchar* msg, instanceData* pData) {
	DEFiRet;

    /* initialize if necessary */
    if(NULL == pData->socket)
		CHKiRet(initZMQ(pData));

/* contrib/omzmq3/omzmq3.c:245 */
static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    if (NULL == s_context) {
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
    if (pData->action == ACTION_BIND) {
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
```

Ïù¥ Ïä¨ÎùºÏù¥Ïä§Î•º ÏàòÎèôÏúºÎ°ú Ksign Î™®Îç∏Ïóê Ï†ÅÏö©Ìï¥ÏÑú Í≤∞Í≥ºÎ•º ÌÉêÏßÄÌï¥Î≥¥ÏïòÎçîÎãà Ï†ïÏÉÅÏúºÎ°ú ÏòàÏ∏°ÌñàÎã§.

---

#### SARDÎäî Ïûò ÌÉêÏßÄÌïòÎäîÎç∞ Ïù¥ CVEÎäî ÌÉêÏßÄ Î™ªÌñàÎçò Ïù¥Ïú†

1. **Î∂ÄÏ†ÅÏ†àÌïú criterion**
   * Ïù¥ Ï∑®ÏïΩÏ†êÏùò Í≤ΩÏö∞ criterionÏúºÎ°ú `zsocket_connect`Ïù¥ Ïû°ÌûàÏßÄ ÏïäÏïÑ Ï†ïÏÉÅÏúºÎ°ú ÌåêÎã®Îêú Í≤ÉÏúºÎ°ú Î≥¥ÏûÑ.

---

## Ï∑®ÏïΩÏ†ê ÏÑ∏Î∂Ä ÏÇ¨Ìï≠

### ‚ùóÔ∏èÏ∑®ÏïΩ ÏΩîÎìú

#### Sink: `before_omzmq3.c:252`

```c
if(-1 == zsocket_connect(pData->socket, (char*)pData->description))
```

**Î¨∏Ï†úÏ†ê**:
* `info->description`ÏùÄ Ïô∏Î∂Ä ÏÑ§Ï†ï ÌååÏùº ÎòêÎäî ÏûÖÎ†•ÏùÑ ÌÜµÌï¥ Ïú†ÏûÖÎêòÎäî ÏÇ¨Ïö©Ïûê Ï†úÏñ¥ Í∞ÄÎä• Î¨∏ÏûêÏó¥ÏûÖÎãàÎã§.
* Ìï¥Îãπ Í∞íÏù¥ Ìè¨Îß∑ Î¨∏ÏûêÏó¥ ÏûêÎ¶¨Ïóê ÏßÅÏ†ë Îì§Ïñ¥Í∞ÄÎØÄÎ°ú, `%s`, `%x` Îì±Ïùò Ìè¨Îß∑ ÏßÄÏ†ïÏûêÍ∞Ä Ìè¨Ìï®Îê† Í≤ΩÏö∞
  ÌòïÏãù Î¨∏ÏûêÏó¥ Ï∑®ÏïΩÏ†ê(CWE-134) Î∞úÏÉù Í∞ÄÎä•

### ‚úÖ Í∞úÏÑ† ÏΩîÎìú

**Ìå®Ïπò ÏúÑÏπò**: `after_omzmq3.c:252`

```c
if(-1 == zsocket_connect(pData->socket, "%s", (char*)pData->description))
```

**Í∞úÏÑ† Î∞©Î≤ï**:

* Ìè¨Îß∑ Î¨∏ÏûêÏó¥ÏùÑ Í≥†Ï†ïÎêú `"%s"`Î°ú Î™ÖÏãúÌïòÏó¨ Ïô∏Î∂Ä ÏûÖÎ†•Ïù¥ Ìè¨Îß∑ÏúºÎ°ú Ìï¥ÏÑùÎêòÏßÄ ÏïäÎèÑÎ°ù Ï°∞Ïπò
* ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÄ Ìè¨Îß∑ Î¨∏ÏûêÏó¥Ïùò Ïù∏Ïûê(`"%s"`, `"%d"` Îì±)ÏóêÎßå Ï†ÑÎã¨ÎêòÎèÑÎ°ù Íµ¨ÏÑ±Ìï¥Ïïº ÌïòÎ©∞, **Ìè¨Îß∑ Î¨∏ÏûêÏó¥ ÏûêÏ≤¥Î°ú ÏÇ¨Ïö©ÎêòÏñ¥ÏÑúÎäî Ïïà Îê®**
#### Ìè¨Îß∑ Î¨∏ÏûêÏó¥: `"%s"`, `"%d"`, `"%x"` Í∞ôÏùÄ Ï∂úÎ†• ÌòïÏãù Î™ÖÎ†πÏù¥ Îì§Ïñ¥ÏûàÎäî Î¨∏ÏûêÏó¥Î°ú, `sprintf`Î•ò Ìï®ÏàòÏùò Îëê Î≤àÏß∏ Ïù∏ÏûêÎ°ú Ïì∞Ïù¥Îäî Î¨∏ÏûêÏó¥
#### `printf`, `sprintf`, `fprintf` Í∞ôÏùÄ Ìï®ÏàòÏùò Îëê Î≤àÏß∏ Ïù∏ÏûêÎ°ú `user_input`Ïù¥ Îì§Ïñ¥Í∞ÄÎ©¥ ÏïàÎêúÎã§Îäî ÏùòÎØ∏

---

## ÌÉêÏßÄ Í≤∞Í≥º
\* cve ÏÑ§Î™ÖÏóê ÎÇòÏò® Ï∑®ÏïΩÌïú Ìï®Ïàò(Caller)Ïóê ÎåÄÌïú Ïä¨ÎùºÏù¥Ïä§ Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞Îßå Ï∂îÏ∂ú
* ÏóÜÏùå