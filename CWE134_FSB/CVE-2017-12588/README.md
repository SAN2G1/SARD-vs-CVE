# ğŸ“ CVE-2017-12588

## ğŸ” ì·¨ì•½ì  ê°œìš”

**ğŸ”— [ì»¤ë°‹ ë§í¬](https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b)** | **ğŸ”— [CVE ë§í¬](https://www.cvedetails.com/cve/CVE-2017-12588/)**  | **ğŸ”— [CWE ë§í¬](https://cwe.mitre.org/data/definitions/134.html)**  


> rsyslog 8.28.0 ì´ì „ ë²„ì „ì˜ `omzmq3` ë° `imzmq3` ëª¨ë“ˆì—ì„œëŠ” ì„¤ëª…(description) í•„ë“œê°€ í˜•ì‹ ë¬¸ìì—´ë¡œ í•´ì„ë˜ëŠ” ë¬¸ì œê°€ ì¡´ì¬í•©ë‹ˆë‹¤.  
> ì´ë¡œ ì¸í•´ ê³µê²©ìëŠ” í¬ë§· ë¬¸ìì—´ ì§€ì •ìë¥¼ í¬í•¨í•œ ì…ë ¥ì„ í†µí•´ **í˜•ì‹ ë¬¸ìì—´ ì·¨ì•½ì (CWE-134)**ì„ ìœ ë°œí•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ì„œë¹„ìŠ¤ ê±°ë¶€ ë˜ëŠ” ë©”ëª¨ë¦¬ ì¡°ì‘ê³¼ ê°™ì€ ì˜í–¥ì„ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* **Source**: ì„¤ëª… ë¬¸ìì—´(`info->description`) â€“ ì™¸ë¶€ ì…ë ¥ì— ì˜í•´ ì„¤ì •ë  ìˆ˜ ìˆìŒ
* **ì·¨ì•½ ì¡°ê±´**: ì„¤ëª…(description) ë¬¸ìì—´ì— í¬ë§· ë¬¸ìì—´ ì§€ì •ì(`%s`, `%x` ë“±)ê°€ í¬í•¨ëœ ê²½ìš°, í•´ë‹¹ ë¬¸ìì—´ì´ í¬ë§· ë¬¸ìì—´ë¡œ ì§ì ‘ ì‚¬ìš©ë¨
* **Sink**: `zsocket_connect()`, `zsocket_bind()` â€“ ë‚´ë¶€ì ìœ¼ë¡œ `printf` ê³„ì—´ í•¨ìˆ˜ì— format stringìœ¼ë¡œ ì „ë‹¬ë¨

---

## íƒì§€ ê²°ê³¼ ìš”ì•½

| ì´ ìŠ¬ë¼ì´ìŠ¤ ìˆ˜ | ì·¨ì•½ìœ¼ë¡œ íƒì§€ | ì •ìƒìœ¼ë¡œ íƒì§€ |
|----------------|----------------|----------------|
| 0ê°œ           | 0ê°œ            | 0ê°œ           |

\* Sink(`zsocket_connect` í•¨ìˆ˜) ê´€ë ¨ ìŠ¬ë¼ì´ìŠ¤ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒ.

ì´ CVE ì·¨ì•½ì ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œ(sink:contrib/omzmq3/omzmq3.c:245)ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.
```
static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    if (NULL == s_context) {
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
    if (pData->action == ACTION_BIND) {
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
```
ì´ ì½”ë“œì—ì„œ Ksign ìŠ¬ë¼ì´ì„œ ë„êµ¬ê°€ ì¶”ì¶œí–ˆì–´ì•¼ í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```c
/* contrib/imzmq3/imzmq3.c:566 */
static int handlePoll(zloop_t __attribute__((unused)) * loop, zmq_pollitem_t *poller, void* pd) {
    smsg_t* pMsg;
    poller_data* pollerData = (poller_data*)pd;

    char* buf = zstr_recv(poller->socket);
    if (msgConstruct(&pMsg) == RS_RET_OK) {
        MsgSetRawMsg(pMsg, buf, strlen(buf));
        MsgSetInputName(pMsg, s_namep);
        MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
        MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
        MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
        MsgSetMSGoffs(pMsg, 0);
        MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
        MsgSetRuleset(pMsg, pollerData->ruleset);
        pMsg->msgFlags = NEEDS_PARSING | PARSE_HOSTNAME;
        submitMsg2(pMsg);

/* tools/rsyslogd.c:975 */
rsRetVal
submitMsg2(smsg_t *pMsg)
{
	qqueue_t *pQueue;
	ruleset_t *pRuleset;
	DEFiRet;

	ISOBJ_TYPE_assert(pMsg, msg);

	pRuleset = MsgGetRuleset(pMsg);
	pQueue = (pRuleset == NULL) ? pMsgQueue : ruleset.GetRulesetQueue(pRuleset);

	/* if a plugin logs a message during shutdown, the queue may no longer exist */
	if(pQueue == NULL) {
		DBGPRINTF("submitMsg2() could not submit message - "
			  "queue does (no longer?) exist - ignored\n");
		FINALIZE;
	}

	qqueueEnqMsg(pQueue, pMsg->flowCtlType, pMsg);

/* runtime/queue.c:3011 */
rsRetVal
qqueueEnqMsg(qqueue_t *pThis, flowControl_t flowCtlType, smsg_t *pMsg)
{
	DEFiRet;
	int iCancelStateSave;
	ISOBJ_TYPE_assert(pThis, qqueue);

	const int isNonDirectQ = pThis->qType != QUEUETYPE_DIRECT;

	if(isNonDirectQ) {
		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &iCancelStateSave);
		d_pthread_mutex_lock(pThis->mut);
	}

	CHKiRet(doEnqSingleObj(pThis, flowCtlType, pMsg));

/* queueAdd()ê°€ ì‹¤ì§ˆì ìœ¼ë¡œ messageë¥¼ ë„£ëŠ” í•¨ìˆ˜ì´ê³ , queue ìƒì„± ì‹œ, queue íƒ€ì…ì— ë”°ë¼ì„œ add í•¨ìˆ˜ê°€ ë‹¬ë¼ì§(diskqueue, linkedqueue ...)
/* runtime/queue.c:2910 */
static rsRetVal
doEnqSingleObj(qqueue_t *pThis, flowControl_t flowCtlType, smsg_t *pMsg)
{
	DEFiRet;
	int err;
	struct timespec t;

	STATSCOUNTER_INC(pThis->ctrEnqueued, pThis->mutCtrEnqueued);
	/* first check if we need to discard this message (which will cause CHKiRet() to exit)
	 */
	CHKiRet(qqueueChkDiscardMsg(pThis, pThis->iQueueSize, pMsg));

	/* handle flow control
	 * There are two different flow control mechanisms: basic and advanced flow control.
	 * Basic flow control has always been implemented and protects the queue structures
	 * in that it makes sure no more data is enqueued than the queue is configured to
	 * support. Enhanced flow control is being added today. There are some sources which
	 * can easily be stopped, e.g. a file reader. This is the case because it is unlikely
	 * that blocking those sources will have negative effects (after all, the file is
	 * continued to be written). Other sources can somewhat be blocked (e.g. the kernel
	 * log reader or the local log stream reader): in general, nothing is lost if messages
	 * from these sources are not picked up immediately. HOWEVER, they can not block for
	 * an extended period of time, as this either causes message loss or - even worse - some
	 * other bad effects (e.g. unresponsive system in respect to the main system log socket).
	 * Finally, there are some (few) sources which can not be blocked at all. UDP syslog is
	 * a prime example. If a UDP message is not received, it is simply lost. So we can't
	 * do anything against UDP sockets that come in too fast. The core idea of advanced
	 * flow control is that we take into account the different natures of the sources and
	 * select flow control mechanisms that fit these needs. This also means, in the end
	 * result, that non-blockable sources like UDP syslog receive priority in the system.
	 * It's a side effect, but a good one ;) -- rgerhards, 2008-03-14
	 */
	if(flowCtlType == eFLOWCTL_FULL_DELAY) {
		while(pThis->iQueueSize >= pThis->iFullDlyMrk&& ! glbl.GetGlobalInputTermState()) {
			/* We have a problem during shutdown if we block eternally. In that
			 * case, the the input thread cannot be terminated. So we wake up
			 * from time to time to check for termination.
			 * TODO/v6(at earliest): check if we could signal the condition during
			 * shutdown. However, this requires new queue registries and thus is
			 * far to much change for a stable version (and I am still not sure it
			 * is worth the effort, given how seldom this situation occurs and how
			 * few resources the wakeups need). -- rgerhards, 2012-05-03
			 * In any case, this was the old code (if we do the TODO):
			 * pthread_cond_wait(&pThis->belowFullDlyWtrMrk, pThis->mut);
			 */
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: FullDelay mark reached for full delayable message "
				   "- blocking, queue size is %d.\n", pThis->iQueueSize);
			timeoutComp(&t, 1000);
			err = pthread_cond_timedwait(&pThis->belowLightDlyWtrMrk, pThis->mut, &t);
			if(err != 0 && err != ETIMEDOUT) {
				/* Something is really wrong now. Report to debug log and abort the
				 * wait. That keeps us running, even though we may lose messages.
				 */
				DBGOPRINT((obj_t*) pThis, "potential program bug: pthread_cond_timedwait()"
				          "/fulldelay returned %d\n", err);
				break;
				
			}
			DBGPRINTF("wti worker in full delay timed out, checking termination...\n");
		}
	} else if(flowCtlType == eFLOWCTL_LIGHT_DELAY && !glbl.GetGlobalInputTermState()) {
		if(pThis->iQueueSize >= pThis->iLightDlyMrk) {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: LightDelay mark reached for light "
			          "delayable message - blocking a bit.\n");
			timeoutComp(&t, 1000); /* 1000 millisconds = 1 second TODO: make configurable */
			err = pthread_cond_timedwait(&pThis->belowLightDlyWtrMrk, pThis->mut, &t);
			if(err != 0 && err != ETIMEDOUT) {
				/* Something is really wrong now. Report to debug log */
				DBGOPRINT((obj_t*) pThis, "potential program bug: pthread_cond_timedwait()"
				          "/lightdelay returned %d\n", err);
				
			}
		}
	}

	/* from our regular flow control settings, we are now ready to enqueue the object.
	 * However, we now need to do a check if the queue permits to add more data. If that
	 * is not the case, basic flow control enters the field, which means we wait for
	 * the queue to become ready or drop the new message. -- rgerhards, 2008-03-14
	 */
	while(   (pThis->iMaxQueueSize > 0 && pThis->iQueueSize >= pThis->iMaxQueueSize)
	      || ((pThis->qType == QUEUETYPE_DISK || pThis->bIsDA) && pThis->sizeOnDiskMax != 0
	      	  && pThis->tVars.disk.sizeOnDisk > pThis->sizeOnDiskMax)) {
		STATSCOUNTER_INC(pThis->ctrFull, pThis->mutCtrFull);
		if(pThis->toEnq == 0 || pThis->bEnqOnly) {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL - configured for immediate discarding QueueSize=%d "
				"MaxQueueSize=%d sizeOnDisk=%lld sizeOnDiskMax=%lld\n", pThis->iQueueSize, pThis->iMaxQueueSize,
				pThis->tVars.disk.sizeOnDisk, pThis->sizeOnDiskMax); 
			STATSCOUNTER_INC(pThis->ctrFDscrd, pThis->mutCtrFDscrd);
			msgDestruct(&pMsg);
			ABORT_FINALIZE(RS_RET_QUEUE_FULL);
		} else {
			DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL - waiting %dms to drain.\n", pThis->toEnq);
			if(glbl.GetGlobalInputTermState()) {
				DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: queue FULL, discard due to FORCE_TERM.\n");
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			}
			timeoutComp(&t, pThis->toEnq);
			if(pthread_cond_timedwait(&pThis->notFull, pThis->mut, &t) != 0) {
				DBGOPRINT((obj_t*) pThis, "doEnqSingleObject: cond timeout, dropping message!\n");
				STATSCOUNTER_INC(pThis->ctrFDscrd, pThis->mutCtrFDscrd);
				msgDestruct(&pMsg);
				ABORT_FINALIZE(RS_RET_QUEUE_FULL);
			}
		dbgoprint((obj_t*) pThis, "doEnqSingleObject: wait solved queue full condition, enqueing\n");
		}
	}

	/* and finally enqueue the message */
	CHKiRet(qqueueAdd(pThis, pMsg));

// ì—¬ê¸°ì„œ ì–´ë–»ê²Œ ì—°ê²°í•´ì•¼í• ì§€ê°€ ë…¼ì˜í•  í¬ì¸íŠ¸ ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤.
// queueì— pConsumerê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, pConsumer í•¨ìˆ˜ì— queueì— ìˆë˜ ë©”ì‹œì§€ê°€ ì…ë ¥ë˜ì–´ ì²˜ë¦¬ëœë‹¤ëŠ” ê±¸ ê°€ì •í•˜ê³ , ë°”ë¡œ enqueueë¡œ ë„˜ì–´ê°€ë„ ë ì§€. ê·¸ë ‡ë‹¤ë©´ ì´ê±¸ ì–´ë–»ê²Œ ìë™í™”í•´ì•¼ í• ì§€...

/* runtime/queue.c:1402 */
rsRetVal qqueueConstruct(qqueue_t **ppThis, queueType_t qType, int iWorkerThreads,
		        int iMaxQueueSize, rsRetVal (*pConsumer)(void*, batch_t*, wti_t*))
{
	DEFiRet;
	qqueue_t *pThis;
	const uchar *const workDir = glblGetWorkDirRaw();

	ASSERT(ppThis != NULL);
	ASSERT(pConsumer != NULL);
	ASSERT(iWorkerThreads >= 0);

	CHKmalloc(pThis = (qqueue_t *)calloc(1, sizeof(qqueue_t)));

	/* we have an object, so let's fill the properties */
	objConstructSetObjInfo(pThis);

	if(workDir != NULL) {
		if((pThis->pszSpoolDir = ustrdup(workDir)) == NULL)
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		pThis->lenSpoolDir = ustrlen(pThis->pszSpoolDir);
	}
	/* set some water marks so that we have useful defaults if none are set specifically */
	pThis->iFullDlyMrk  = -1;
	pThis->iLightDlyMrk = -1;
	pThis->iMaxFileSize = 1024 * 1024; /* default is 1 MiB */
	pThis->iQueueSize = 0;
	pThis->nLogDeq = 0;
	pThis->useCryprov = 0;
	pThis->iMaxQueueSize = iMaxQueueSize;
	pThis->pConsumer = pConsumer;

/* action.c:509 */
rsRetVal
actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
{
	DEFiRet;
	uchar pszAName[64]; /* friendly name of our action */

	if(!strcmp((char*)modGetName(pThis->pMod), "builtin:omdiscard")) {
		/* discard actions will be optimized out */
		FINALIZE;
	}
	/* generate a friendly name for us action stats */
	if(pThis->pszName == NULL) {
		snprintf((char*) pszAName, sizeof(pszAName), "action %d", pThis->iActionNbr);
		pThis->pszName = ustrdup(pszAName);
	}

	/* cache transactional attribute */
	pThis->isTransactional = pThis->pMod->mod.om.supportsTX;
	if(pThis->isTransactional) {
		int i;
		for(i = 0 ; i < pThis->iNumTpls ; ++i) {
			if(pThis->peParamPassing[i] != ACT_STRING_PASSING) {
		}
	}


	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&pThis->statsobj));
	CHKiRet(statsobj.SetName(pThis->statsobj, pThis->pszName));
	CHKiRet(statsobj.SetOrigin(pThis->statsobj, (uchar*)"core.action"));

	STATSCOUNTER_INIT(pThis->ctrProcessed, pThis->mutCtrProcessed);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("processed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrProcessed));

	STATSCOUNTER_INIT(pThis->ctrFail, pThis->mutCtrFail);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("failed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrFail));

	STATSCOUNTER_INIT(pThis->ctrSuspend, pThis->mutCtrSuspend);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("suspended"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrSuspend));
	STATSCOUNTER_INIT(pThis->ctrSuspendDuration, pThis->mutCtrSuspendDuration);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("suspended.duration"),
		ctrType_IntCtr, 0, &pThis->ctrSuspendDuration));

	STATSCOUNTER_INIT(pThis->ctrResume, pThis->mutCtrResume);
	CHKiRet(statsobj.AddCounter(pThis->statsobj, UCHAR_CONSTANT("resumed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &pThis->ctrResume));

	CHKiRet(statsobj.ConstructFinalize(pThis->statsobj));

	/* create our queue */

	/* generate a friendly name for the queue */
	snprintf((char*) pszAName, sizeof(pszAName), "%s queue",
		 pThis->pszName);

	/* now check if we can run the action in "firehose mode" during stage one of 
	 * its processing (that is before messages are enqueued into the action q).
	 * This is only possible if some features, which require strict sequence, are
	 * not used. Thankfully, that is usually the case. The benefit of firehose
	 * mode is much faster processing (and simpler code) -- rgerhards, 2010-06-08
	 */
	if(   pThis->iExecEveryNthOccur > 1
	   || pThis->iSecsExecOnceInterval
	  ) {
		DBGPRINTF("info: firehose mode disabled for action because "
		          "iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n",
			  pThis->iExecEveryNthOccur, pThis->iSecsExecOnceInterval);
		pThis->submitToActQ = doSubmitToActionQComplex;
	} else if(pThis->bWriteAllMarkMsgs) {
		/* full firehose submission mode, default case*/
		pThis->submitToActQ = doSubmitToActionQ;
	} else {
		/* nearly full-speed submission mode */
		pThis->submitToActQ = doSubmitToActionQNotAllMark;
	}

	/* create queue */
	/* action queues always (for now) have just one worker. This may change when
	 * we begin to implement an interface the enable output modules to request
	 * to be run on multiple threads. So far, this is forbidden by the interface
	 * spec. -- rgerhards, 2008-01-30
	 */
    /* rsRetVal qqueueConstruct(qqueue_t **ppThis, queueType_t qType, int iWorkerThreads,
		        int iMaxQueueSize, rsRetVal (*pConsumer)(void*, batch_t*, wti_t*)) */
	CHKiRet(qqueueConstruct(&pThis->pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
					processBatchMain));

/* action.c:1416 */
static rsRetVal
processBatchMain(void *__restrict__ const pVoid,
	batch_t *__restrict__ const pBatch,
	wti_t *__restrict__ const pWti)
{
	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
	int i;
	struct syslogTime ttNow;
	DEFiRet;

	wtiResetExecState(pWti, pBatch);
	/* indicate we have not yet read the date */
	ttNow.year = 0;

	for(i = 0 ; i < batchNumMsgs(pBatch) && !*pWti->pbShutdownImmediate ; ++i) {
		if(batchIsValidElem(pBatch, i)) {
			/* we do not check error state below, because aborting would be
			 * more harmful than continuing.
			 */
			processMsgMain(pAction, pWti, pBatch->pElem[i].pMsg, &ttNow);

/* action.c:1382 */
static rsRetVal
processMsgMain(action_t *__restrict__ const pAction,
	wti_t *__restrict__ const pWti,
	smsg_t *__restrict__ const pMsg,
	struct syslogTime *ttNow)
{
	DEFiRet;

	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));

	if(pAction->isTransactional) {
		pWti->actWrkrInfo[pAction->iActionNbr].pAction = pAction;
		DBGPRINTF("action '%s': is transactional - executing in commit phase\n", pAction->pszName);
		actionPrepare(pAction, pWti);
		iRet = getReturnCode(pAction, pWti);
		FINALIZE;
	}

	iRet = actionProcessMessage(pAction,
				    pWti->actWrkrInfo[pAction->iActionNbr].p.nontx.actParams,
				    pWti);

/* action.c:1171 */
static rsRetVal actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
{
	DEFiRet;

	CHKiRet(actionPrepare(pThis, pWti));
	if(pThis->pMod->mod.om.SetShutdownImmdtPtr != NULL)
		pThis->pMod->mod.om.SetShutdownImmdtPtr(pThis->pModData, pWti->pbShutdownImmediate);
	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
		CHKiRet(actionCallDoAction(pThis, actParams, pWti));

/* action.c:1128 */
static rsRetVal actionCallDoAction(action_t *__restrict__ const pThis, 	actWrkrIParams_t *__restrict__ onst iparams, wti_t *__restrict__ const pWti) {
	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	int i;
	DEFiRet;

	DBGPRINTF("entering actionCalldoAction(), state: %s, actionNbr %d\n",
		  getActStateName(pThis, pWti), pThis->iActionNbr);

	iRet = pThis->pMod->mod.om.doAction(param,
				            pWti->actWrkrInfo[pThis->iActionNbr].actWrkrData);


/* contrib/omzmq3/omzmq3.c:359 */
static rsRetVal doAction(void * pMsgData, wrkrInstanceData_t __attribute__((unused)) *pWrkrData){ 
    uchar **ppString = (uchar **) pMsgData;  rsRetVal iRet = RS_RET_OK;
	instanceData *pData = pWrkrData->pData;
	/* ppString may be NULL if the output module requested no strings */
	pthread_mutex_lock(&mutDoAct);
	iRet = writeZMQ(ppString[0], pData);
	pthread_mutex_unlock(&mutDoAct);
    do{  return iRet; }while(0);
}

/* contrib/omzmq3/omzmq3.c:268 */
rsRetVal writeZMQ(uchar* msg, instanceData* pData) {
	DEFiRet;

    /* initialize if necessary */
    if(NULL == pData->socket)
		CHKiRet(initZMQ(pData));

/* contrib/omzmq3/omzmq3.c:245 */
static rsRetVal initZMQ(instanceData* pData) {
    DEFiRet;
    if (NULL == s_context) {
    pData->socket = zsocket_new(s_context, pData->type);
    if (NULL == pData->socket) {
    if (pData->action == ACTION_BIND) {
        if(-1 == zsocket_bind(pData->socket, (char*)pData->description)) {
```
[
    {
        "FileName": "manager.c",
        "Caller": "add_server",
        "Source": false,
        "Sink": true,
        "idx": 0,
        "CWE-ID": "CWE-78",
        "category": "CallExpression",
        "criterion": "system",
        "line": 42,
        "label": -3,
        "slices": [
            "int main(int argc, char **argv)\n",
            "{\n",
            "    int sfd;\n",
            "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
            "        struct sockaddr_un svaddr;\n",
            "        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);\n",
            "        if (sfd == -1) {\n",
            "        setnonblocking(sfd);\n",
            "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
            "    } \n",
            "    manager.fd = sfd;\n",
            "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
            "}\n",
            "static void manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
            "{\n",
            "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
            "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
            "    if (r == -1) {\n",
            "    if (r > BUF_SIZE / 2) {\n",
            "    char *action = get_action(buf, r);\n",
            "    if (action == NULL) {\n",
            "    if (strcmp(action, \"add\") == 0) {\n",
            "        struct server *server = get_server(buf, r);\n",
            "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
            "        int ret = add_server(manager, server);\n",
            "}\n",
            "static int add_server(struct manager_ctx *manager, struct server *server)\n",
            "{\n",
            "    int ret = check_port(manager, server);\n",
            "    cork_hash_table_put(server_table, (void *)server->port, (void *)server, &new, NULL, NULL);\n",
            "    char *cmd = construct_command_line(manager, server);\n",
            "    construct_command_line(struct manager_ctx *manager, struct server *server){\n",
            "        static char cmd[BUF_SIZE];\n",
            "        char *method = manager->method;\n",
            "        int i;\n",
            "        build_config(working_dir, server);\n",
            "        if (server->method) method = server->method;\n",
            "        memset(cmd, 0, BUF_SIZE);\n",
            "        snprintf(cmd, BUF_SIZE,\n",
            "                \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n",
            "                executable, method, manager->manager_address,\n",
            "                working_dir, server->port, working_dir, server->port);\n",
            "        return cmd;\n",
            "    }\n",
            "    if (system(cmd) == -1) {\n",
            "}\n"
        ]
    }
]
```

ì´ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ Ksign ëª¨ë¸ì— ì ìš©í•´ì„œ ê²°ê³¼ë¥¼ íƒì§€í•´ë³´ì•˜ë”ë‹ˆ ì •ìƒìœ¼ë¡œ ì˜ˆì¸¡í–ˆë‹¤.

---

#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 

1. **ë¶€ì ì ˆí•œ criterion**
   * ì´ ì·¨ì•½ì ì˜ ê²½ìš° criterionìœ¼ë¡œ `zsocket_connect`ì´ ì¡íˆì§€ ì•Šì•„ ì •ìƒìœ¼ë¡œ íŒë‹¨ëœ ê²ƒìœ¼ë¡œ ë³´ì„.

---

## ì·¨ì•½ì  ì„¸ë¶€ ì‚¬í•­

### â—ï¸ì·¨ì•½ ì½”ë“œ

#### Sink: `before_omzmq3.c:252`

```c
if(-1 == zsocket_connect(pData->socket, (char*)pData->description))
```

**ë¬¸ì œì **:
* `info->description`ì€ ì™¸ë¶€ ì„¤ì • íŒŒì¼ ë˜ëŠ” ì…ë ¥ì„ í†µí•´ ìœ ì…ë˜ëŠ” ì‚¬ìš©ì ì œì–´ ê°€ëŠ¥ ë¬¸ìì—´ì…ë‹ˆë‹¤.
* í•´ë‹¹ ê°’ì´ í¬ë§· ë¬¸ìì—´ ìë¦¬ì— ì§ì ‘ ë“¤ì–´ê°€ë¯€ë¡œ, `%s`, `%x` ë“±ì˜ í¬ë§· ì§€ì •ìê°€ í¬í•¨ë  ê²½ìš°
  í˜•ì‹ ë¬¸ìì—´ ì·¨ì•½ì (CWE-134) ë°œìƒ ê°€ëŠ¥

### âœ… ê°œì„  ì½”ë“œ

**íŒ¨ì¹˜ ìœ„ì¹˜**: `after_omzmq3.c:252`

```c
if(-1 == zsocket_connect(pData->socket, "%s", (char*)pData->description))
```

**ê°œì„  ë°©ë²•**:

* í¬ë§· ë¬¸ìì—´ì„ ê³ ì •ëœ `"%s"`ë¡œ ëª…ì‹œí•˜ì—¬ ì™¸ë¶€ ì…ë ¥ì´ í¬ë§·ìœ¼ë¡œ í•´ì„ë˜ì§€ ì•Šë„ë¡ ì¡°ì¹˜
* ì‚¬ìš©ì ì…ë ¥ì€ í¬ë§· ë¬¸ìì—´ì˜ ì¸ì(`"%s"`, `"%d"` ë“±)ì—ë§Œ ì „ë‹¬ë˜ë„ë¡ êµ¬ì„±í•´ì•¼ í•˜ë©°, **í¬ë§· ë¬¸ìì—´ ìì²´ë¡œ ì‚¬ìš©ë˜ì–´ì„œëŠ” ì•ˆ ë¨**
#### í¬ë§· ë¬¸ìì—´: `"%s"`, `"%d"`, `"%x"` ê°™ì€ ì¶œë ¥ í˜•ì‹ ëª…ë ¹ì´ ë“¤ì–´ìˆëŠ” ë¬¸ìì—´ë¡œ, `sprintf`ë¥˜ í•¨ìˆ˜ì˜ ë‘ ë²ˆì§¸ ì¸ìë¡œ ì“°ì´ëŠ” ë¬¸ìì—´
#### `printf`, `sprintf`, `fprintf` ê°™ì€ í•¨ìˆ˜ì˜ ë‘ ë²ˆì§¸ ì¸ìë¡œ `user_input`ì´ ë“¤ì–´ê°€ë©´ ì•ˆëœë‹¤ëŠ” ì˜ë¯¸

---

## íƒì§€ ê²°ê³¼
\* cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller)ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ ê´€ë ¨ ë°ì´í„°ë§Œ ì¶”ì¶œ
* ì—†ìŒ