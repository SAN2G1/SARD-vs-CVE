[{"FileName": "credd_before.cpp", "Caller": "SaveCredentialList", "Source": false, "Sink": false, "idx": 0, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 544, "label": -3, "slices": ["  FILE * fp = safe_fopen_wrapper(cred_index_file, \"w\");\n", "  if (!fp) {\n", "  classad::ClassAdXMLUnParser unparser;\n", "  CredentialWrapper * pCred = NULL;\n", "  while (credentials.Next(pCred)) {\n", "    const classad::ClassAd * pclassad = pCred->cred->GetMetadata();\n", "    std::string buff;\n", "    unparser.Unparse (buff, &temp_classad);\n", "    fprintf (fp, \"%s\\n\", buff.c_str());\n", "  fclose (fp);\n"], "tokenized": "STRUCT1 *Var1=FUNC1(Var2,STRING); \nif (!Var1){\nCLASS1::STRUCT2  Var3; \nSTRUCT3 *Var4=NULL ; \nwhile (Var5.FUNC2(Var4)){\nconst CLASS1::STRUCT4 *Var6=Var4->memberVar1->FUNC3(); \nCLASS2::STRUCT5  Var7; \nVar3.FUNC4(Var7,&Var8); \nfprintf(Var1,STRING,Var7.FUNC5()); \nfclose(Var1); \n"}, {"FileName": "credd_before.cpp", "Caller": "SaveCredentialList", "Source": false, "Sink": false, "idx": 1, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fclose", "line": 547, "label": -3, "slices": ["  FILE * fp = safe_fopen_wrapper(cred_index_file, \"w\");\n", "  if (!fp) {\n", "  CredentialWrapper * pCred = NULL;\n", "  while (credentials.Next(pCred)) {\n", "    const classad::ClassAd * pclassad = pCred->cred->GetMetadata();\n", "    std::string buff;\n", "    fprintf (fp, \"%s\\n\", buff.c_str());\n", "  fclose (fp);\n"], "tokenized": "STRUCT1 *Var1=FUNC1(Var2,STRING); \nif (!Var1){\nSTRUCT2 *Var3=NULL ; \nwhile (Var4.FUNC2(Var3)){\nconst CLASS1::STRUCT3 *Var5=Var3->memberVar1->FUNC3(); \nCLASS2::STRUCT4  Var6; \nfprintf(Var1,STRING,Var6.FUNC4()); \nfclose(Var1); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadCredentialList", "Source": false, "Sink": false, "idx": 2, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fgets", "line": 581, "label": -3, "slices": ["  classad::ClassAdXMLParser parser;\n", "  char buff[50000];\n", "  FILE * fp = safe_fopen_wrapper(cred_index_file, \"r\");\n", "  if (!fp) {\n", "  while (fgets(buff, 50000, fp)) {\n", "    if ((buff[0] == '\\n') || (buff[0] == '\\r')) {\n", "\tclassad::ClassAd * classad = parser.ParseClassAd (buff);\n", "    int type=0;\n", "    if ((!classad) || (!classad->EvaluateAttrInt (\"Type\", type))) {\n", "      dprintf (D_ALWAYS, \"Invalid classad %s\\n\", buff);\n", "      fclose (fp);\n", "  fclose (fp);\n"], "tokenized": "CLASS1::STRUCT1  Var1; \nchar  Var2[50000]; \nSTRUCT2 *Var3=FUNC1(Var4,STRING); \nif (!Var3){\nwhile (fgets(Var2,50000,Var3)){\nif ((Var2[0]==  Var5)||(Var2[0]==  Var6)){\nCLASS1::STRUCT3 *Var7=Var1.FUNC2(Var2); \nint  Var8=0; \nif ((!Var7)||(!Var7->FUNC3(STRING,Var8))){\nFUNC4(Var9,STRING,Var2); \nfclose(Var3); \nfclose(Var3); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadCredentialList", "Source": false, "Sink": false, "idx": 3, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fclose", "line": 592, "label": -3, "slices": ["  char buff[50000];\n", "  FILE * fp = safe_fopen_wrapper(cred_index_file, \"r\");\n", "  if (!fp) {\n", "  while (fgets(buff, 50000, fp)) {\n", "    if ((buff[0] == '\\n') || (buff[0] == '\\r')) {\n", "\tclassad::ClassAd * classad = parser.ParseClassAd (buff);\n", "    int type=0;\n", "    if ((!classad) || (!classad->EvaluateAttrInt (\"Type\", type))) {\n", "      fclose (fp);\n", "  fclose (fp);\n"], "tokenized": "char  Var1[50000]; \nSTRUCT1 *Var2=FUNC1(Var3,STRING); \nif (!Var2){\nwhile (fgets(Var1,50000,Var2)){\nif ((Var1[0]==  Var4)||(Var1[0]==  Var5)){\nCLASS1::STRUCT2 *Var6=Var7.FUNC2(Var1); \nint  Var8=0; \nif ((!Var6)||(!Var6->FUNC3(STRING,Var8))){\nfclose(Var2); \nfclose(Var2); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadCredentialList", "Source": false, "Sink": false, "idx": 4, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fclose", "line": 604, "label": -3, "slices": ["  char buff[50000];\n", "  FILE * fp = safe_fopen_wrapper(cred_index_file, \"r\");\n", "  if (!fp) {\n", "  while (fgets(buff, 50000, fp)) {\n", "    if ((buff[0] == '\\n') || (buff[0] == '\\r')) {\n", "\tclassad::ClassAd * classad = parser.ParseClassAd (buff);\n", "    int type=0;\n", "    if ((!classad) || (!classad->EvaluateAttrInt (\"Type\", type))) {\n", "      fclose (fp);\n", "  fclose (fp);\n"], "tokenized": "char  Var1[50000]; \nSTRUCT1 *Var2=FUNC1(Var3,STRING); \nif (!Var2){\nwhile (fgets(Var1,50000,Var2)){\nif ((Var1[0]==  Var4)||(Var1[0]==  Var5)){\nCLASS1::STRUCT2 *Var6=Var7.FUNC2(Var1); \nint  Var8=0; \nif ((!Var6)||(!Var6->FUNC3(STRING,Var8))){\nfclose(Var2); \nfclose(Var2); \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 5, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strerror", "line": 709, "label": -3, "slices": ["  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"get_delegation pipe() failed: %s\\n\", strerror(errno) );\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n"], "tokenized": "const char *Var1=Var2->FUNC1(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT1 *) Var2->memberVar1)->FUNC2() == NULL ){\nSTRUCT2  Var5=FUNC3(NULL ); \nif (Var2->memberVar2 !=  Var6){\nSTRUCT2  Var7=Var2->memberVar3; \nconst char *Var8=((STRUCT1 *) Var2->memberVar1)->FUNC4(); \nif (Var4 == -1){\nFUNC5(Var9,STRING,strerror(Var10)); \nconst char *Var11=Var2->memberVar1->FUNC6(); \nint  Var12=FUNC7(((STRUCT1 *) Var2->memberVar1)->FUNC2()); \nint  Var13=Var14->FUNC8(\nVar15,//Var16\nVar17,//Var17\nVar18,//Var19\nVar20,//Var21\nVar22,//Var23\n&Var24,//Var25\nNULL ,//Var26\nNULL ,//Var27\nNULL ,//Var28\nVar29); //Var30/Var31/STRUCT3  Var32\n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 6, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "write", "line": 714, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "    dprintf (D_ALWAYS, \"Skipping %s\\n\", proxy->cred->GetName());\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "    if (now - time_started > 500) {\n", "      daemonCore->Send_Signal (proxy->get_delegation_pid, SIGKILL);\n", "  proxy->get_delegation_proc_start_time = now;\n", "  MyString strBuff;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerDN()) {\n", "    strBuff+= ((X509Credential*)proxy->cred)->GetMyProxyServerDN();\n", "  strBuff+=proxy->GetStorageName();\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (myproxy_password == NULL ) {\n", "    dprintf (D_ALWAYS, \"No MyProxy password specified for %s:%s\\n\",\n\t     proxy->cred->GetName(),\n\t     proxy->cred->GetOwner());\n", "    myproxy_password = \"\";\n", "  status = pipe (proxy->get_delegation_password_pipe);\n", "  if (status == -1) {\n", "\tproxy->get_delegation_reset();\n", "  write (proxy->get_delegation_password_pipe[1],\n\t myproxy_password,\n\t strlen (myproxy_password));\n", "  write (proxy->get_delegation_password_pipe[1], \"\\n\", 1);\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if\t(\t((X509Credential*)proxy->cred)->GetCredentialName() && \n  \t\t\t( ((X509Credential*)proxy->cred)->GetCredentialName() )[0] ) {\n", "\t  args.AppendArg(((X509Credential*)proxy->cred)->GetCredentialName());\n", "  proxy->get_delegation_err_filename = create_temp_file();\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tproxy->get_delegation_reset();\n", "  status = chmod (proxy->get_delegation_err_filename, 0600);\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"chmod() get_delegation_err_filename %s failed: %s\\n\",\n\t\t\tproxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_err_fd = safe_open_wrapper_follow(proxy->get_delegation_err_filename,O_RDWR);\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "    dprintf (D_ALWAYS, \"Error opening get_delegation file %s: %s\\n\",\n\t     proxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  int arrIO[3];\n", "  arrIO[0]=proxy->get_delegation_password_pipe[0]; //stdin\n", "  arrIO[2]=proxy->get_delegation_err_fd; // stderr\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  if (pid == FALSE) {\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_pid = pid;\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nFUNC4(Var5,STRING,Var1->memberVar1->FUNC5()); \nSTRUCT3  Var6=FUNC6(NULL ); \nif (Var1->memberVar2 !=  Var7){\nSTRUCT3  Var8=Var1->memberVar3; \nif (Var6-Var8>500){\nVar9->FUNC7(Var1->memberVar2,Var10); \nVar1->memberVar3=Var6; \nSTRUCT4  Var11; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC8()){\nVar11 FUNC9((STRUCT2 *) Var1->memberVar1)->FUNC8(); \nVar11  FUNC9  Var1->FUNC2(); \nconst char *Var12=((STRUCT2 *) Var1->memberVar1)->FUNC10(); \nif (Var12 == NULL ){\nFUNC4(Var5,STRING,\nVar1->memberVar1->FUNC5(),\nVar1->memberVar1->FUNC11()); \nVar12=STRING; \nVar4=FUNC12(Var1->memberVar4); \nif (Var4 == -1){\nVar1->FUNC13(); \nwrite(Var1->memberVar4[1],\nVar12,\nstrlen(Var12)); \nwrite(Var1->memberVar4[1],STRING,1); \nconst char *Var13=Var1->memberVar1->FUNC14(); \nVar3=FUNC15(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var14=FUNC16(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT5  Var15; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC17()&&\n(((STRUCT2 *) Var1->memberVar1)->FUNC17())[0]){\nVar15.FUNC18(((STRUCT2 *) Var1->memberVar1)->FUNC17()); \nVar1->memberVar5=FUNC19(); \nif (Var1->memberVar5 == NULL ){\nVar1->FUNC13(); \nVar4=chmod(Var1->memberVar5,0600); \nif (Var4 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nVar1->memberVar6=FUNC20(Var1->memberVar5,Var17); \nif (Var1->memberVar6 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nint  Var18[3]; \nVar18[0]=Var1->memberVar4[0]; //stdin\nVar18[2]=Var1->memberVar6; //Var19\nchar *Var20=FUNC21(STRING); \nif (!Var20){\nint  Var21=Var9->FUNC22(\nVar20,//Var22\nVar15,//Var15\nVar23,//Var24\nVar25,//Var26\nVar27,//Var28\n&Var29,//Var30\nNULL ,//Var31\nNULL ,//Var32\nNULL ,//Var33\nVar18); //Var34/Var35/STRUCT6  Var36\nif (Var21 ==  Var27){\nVar1->FUNC13(); \nVar1->memberVar2=Var21; \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 7, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 714, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "    dprintf (D_ALWAYS, \"Skipping %s\\n\", proxy->cred->GetName());\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "    if (now - time_started > 500) {\n", "      daemonCore->Send_Signal (proxy->get_delegation_pid, SIGKILL);\n", "  proxy->get_delegation_proc_start_time = now;\n", "  MyString strBuff;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerDN()) {\n", "    strBuff+= ((X509Credential*)proxy->cred)->GetMyProxyServerDN();\n", "  strBuff+=proxy->GetStorageName();\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (myproxy_password == NULL ) {\n", "    dprintf (D_ALWAYS, \"No MyProxy password specified for %s:%s\\n\",\n\t     proxy->cred->GetName(),\n\t     proxy->cred->GetOwner());\n", "    myproxy_password = \"\";\n", "  status = pipe (proxy->get_delegation_password_pipe);\n", "  if (status == -1) {\n", "\tproxy->get_delegation_reset();\n", "  write (proxy->get_delegation_password_pipe[1],\n\t myproxy_password,\n\t strlen (myproxy_password));\n", "  write (proxy->get_delegation_password_pipe[1], \"\\n\", 1);\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if\t(\t((X509Credential*)proxy->cred)->GetCredentialName() && \n  \t\t\t( ((X509Credential*)proxy->cred)->GetCredentialName() )[0] ) {\n", "\t  args.AppendArg(((X509Credential*)proxy->cred)->GetCredentialName());\n", "  proxy->get_delegation_err_filename = create_temp_file();\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tproxy->get_delegation_reset();\n", "  status = chmod (proxy->get_delegation_err_filename, 0600);\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"chmod() get_delegation_err_filename %s failed: %s\\n\",\n\t\t\tproxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_err_fd = safe_open_wrapper_follow(proxy->get_delegation_err_filename,O_RDWR);\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "    dprintf (D_ALWAYS, \"Error opening get_delegation file %s: %s\\n\",\n\t     proxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  int arrIO[3];\n", "  arrIO[0]=proxy->get_delegation_password_pipe[0]; //stdin\n", "  arrIO[2]=proxy->get_delegation_err_fd; // stderr\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  if (pid == FALSE) {\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_pid = pid;\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nFUNC4(Var5,STRING,Var1->memberVar1->FUNC5()); \nSTRUCT3  Var6=FUNC6(NULL ); \nif (Var1->memberVar2 !=  Var7){\nSTRUCT3  Var8=Var1->memberVar3; \nif (Var6-Var8>500){\nVar9->FUNC7(Var1->memberVar2,Var10); \nVar1->memberVar3=Var6; \nSTRUCT4  Var11; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC8()){\nVar11 FUNC9((STRUCT2 *) Var1->memberVar1)->FUNC8(); \nVar11  FUNC9  Var1->FUNC2(); \nconst char *Var12=((STRUCT2 *) Var1->memberVar1)->FUNC10(); \nif (Var12 == NULL ){\nFUNC4(Var5,STRING,\nVar1->memberVar1->FUNC5(),\nVar1->memberVar1->FUNC11()); \nVar12=STRING; \nVar4=FUNC12(Var1->memberVar4); \nif (Var4 == -1){\nVar1->FUNC13(); \nwrite(Var1->memberVar4[1],\nVar12,\nstrlen(Var12)); \nwrite(Var1->memberVar4[1],STRING,1); \nconst char *Var13=Var1->memberVar1->FUNC14(); \nVar3=FUNC15(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var14=FUNC16(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT5  Var15; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC17()&&\n(((STRUCT2 *) Var1->memberVar1)->FUNC17())[0]){\nVar15.FUNC18(((STRUCT2 *) Var1->memberVar1)->FUNC17()); \nVar1->memberVar5=FUNC19(); \nif (Var1->memberVar5 == NULL ){\nVar1->FUNC13(); \nVar4=chmod(Var1->memberVar5,0600); \nif (Var4 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nVar1->memberVar6=FUNC20(Var1->memberVar5,Var17); \nif (Var1->memberVar6 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nint  Var18[3]; \nVar18[0]=Var1->memberVar4[0]; //stdin\nVar18[2]=Var1->memberVar6; //Var19\nchar *Var20=FUNC21(STRING); \nif (!Var20){\nint  Var21=Var9->FUNC22(\nVar20,//Var22\nVar15,//Var15\nVar23,//Var24\nVar25,//Var26\nVar27,//Var28\n&Var29,//Var30\nNULL ,//Var31\nNULL ,//Var32\nNULL ,//Var33\nVar18); //Var34/Var35/STRUCT6  Var36\nif (Var21 ==  Var27){\nVar1->FUNC13(); \nVar1->memberVar2=Var21; \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 8, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "write", "line": 717, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "    dprintf (D_ALWAYS, \"Skipping %s\\n\", proxy->cred->GetName());\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "    if (now - time_started > 500) {\n", "      daemonCore->Send_Signal (proxy->get_delegation_pid, SIGKILL);\n", "  proxy->get_delegation_proc_start_time = now;\n", "  MyString strBuff;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerDN()) {\n", "    strBuff+= ((X509Credential*)proxy->cred)->GetMyProxyServerDN();\n", "  strBuff+=proxy->GetStorageName();\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (myproxy_password == NULL ) {\n", "    dprintf (D_ALWAYS, \"No MyProxy password specified for %s:%s\\n\",\n\t     proxy->cred->GetName(),\n\t     proxy->cred->GetOwner());\n", "  status = pipe (proxy->get_delegation_password_pipe);\n", "  if (status == -1) {\n", "\tproxy->get_delegation_reset();\n", "  write (proxy->get_delegation_password_pipe[1],\n\t myproxy_password,\n\t strlen (myproxy_password));\n", "  write (proxy->get_delegation_password_pipe[1], \"\\n\", 1);\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if\t(\t((X509Credential*)proxy->cred)->GetCredentialName() && \n  \t\t\t( ((X509Credential*)proxy->cred)->GetCredentialName() )[0] ) {\n", "\t  args.AppendArg(((X509Credential*)proxy->cred)->GetCredentialName());\n", "  proxy->get_delegation_err_filename = create_temp_file();\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tproxy->get_delegation_reset();\n", "  status = chmod (proxy->get_delegation_err_filename, 0600);\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"chmod() get_delegation_err_filename %s failed: %s\\n\",\n\t\t\tproxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_err_fd = safe_open_wrapper_follow(proxy->get_delegation_err_filename,O_RDWR);\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "    dprintf (D_ALWAYS, \"Error opening get_delegation file %s: %s\\n\",\n\t     proxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  int arrIO[3];\n", "  arrIO[0]=proxy->get_delegation_password_pipe[0]; //stdin\n", "  arrIO[2]=proxy->get_delegation_err_fd; // stderr\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  if (pid == FALSE) {\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_pid = pid;\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nFUNC4(Var5,STRING,Var1->memberVar1->FUNC5()); \nSTRUCT3  Var6=FUNC6(NULL ); \nif (Var1->memberVar2 !=  Var7){\nSTRUCT3  Var8=Var1->memberVar3; \nif (Var6-Var8>500){\nVar9->FUNC7(Var1->memberVar2,Var10); \nVar1->memberVar3=Var6; \nSTRUCT4  Var11; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC8()){\nVar11 FUNC9((STRUCT2 *) Var1->memberVar1)->FUNC8(); \nVar11  FUNC9  Var1->FUNC2(); \nconst char *Var12=((STRUCT2 *) Var1->memberVar1)->FUNC10(); \nif (Var12 == NULL ){\nFUNC4(Var5,STRING,\nVar1->memberVar1->FUNC5(),\nVar1->memberVar1->FUNC11()); \nVar4=FUNC12(Var1->memberVar4); \nif (Var4 == -1){\nVar1->FUNC13(); \nwrite(Var1->memberVar4[1],\nVar12,\nstrlen(Var12)); \nwrite(Var1->memberVar4[1],STRING,1); \nconst char *Var13=Var1->memberVar1->FUNC14(); \nVar3=FUNC15(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var14=FUNC16(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT5  Var15; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC17()&&\n(((STRUCT2 *) Var1->memberVar1)->FUNC17())[0]){\nVar15.FUNC18(((STRUCT2 *) Var1->memberVar1)->FUNC17()); \nVar1->memberVar5=FUNC19(); \nif (Var1->memberVar5 == NULL ){\nVar1->FUNC13(); \nVar4=chmod(Var1->memberVar5,0600); \nif (Var4 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nVar1->memberVar6=FUNC20(Var1->memberVar5,Var17); \nif (Var1->memberVar6 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nint  Var18[3]; \nVar18[0]=Var1->memberVar4[0]; //stdin\nVar18[2]=Var1->memberVar6; //Var19\nchar *Var20=FUNC21(STRING); \nif (!Var20){\nint  Var21=Var9->FUNC22(\nVar20,//Var22\nVar15,//Var15\nVar23,//Var24\nVar25,//Var26\nVar27,//Var28\n&Var29,//Var30\nNULL ,//Var31\nNULL ,//Var32\nNULL ,//Var33\nVar18); //Var34/Var35/STRUCT6  Var36\nif (Var21 ==  Var27){\nVar1->FUNC13(); \nVar1->memberVar2=Var21; \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 9, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "free", "line": 737, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "  proxy->get_delegation_proc_start_time = now;\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (status == -1) {\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  args.AppendArg(myproxy_host);\n", "  if ( myproxy_host != NULL ) {\n", "\t  free ( myproxy_host );\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nSTRUCT3  Var5=FUNC4(NULL ); \nif (Var1->memberVar2 !=  Var6){\nSTRUCT3  Var7=Var1->memberVar3; \nVar1->memberVar3=Var5; \nconst char *Var8=((STRUCT2 *) Var1->memberVar1)->FUNC5(); \nif (Var4 == -1){\nconst char *Var9=Var1->memberVar1->FUNC6(); \nVar3=FUNC7(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var10=FUNC8(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT4  Var11; \nVar11.FUNC9(Var3); \nif (Var3 != NULL ){\nfree(Var3); \nint  Var12=Var13->FUNC10(\nVar14,//Var15\nVar11,//Var11\nVar16,//Var17\nVar18,//Var19\nVar20,//Var21\n&Var22,//Var23\nNULL ,//Var24\nNULL ,//Var25\nNULL ,//Var26\nVar27); //Var28/Var29/STRUCT5  Var30\n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 10, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strerror", "line": 770, "label": -3, "slices": ["  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (status == -1) {\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tdprintf (D_ALWAYS, \"get_delegation create_temp_file() failed: %s\\n\",\n\t\t\tstrerror(errno) );\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n"], "tokenized": "const char *Var1=Var2->FUNC1(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT1 *) Var2->memberVar1)->FUNC2() == NULL ){\nSTRUCT2  Var5=FUNC3(NULL ); \nif (Var2->memberVar2 !=  Var6){\nSTRUCT2  Var7=Var2->memberVar3; \nconst char *Var8=((STRUCT1 *) Var2->memberVar1)->FUNC4(); \nif (Var4 == -1){\nconst char *Var9=Var2->memberVar1->FUNC5(); \nint  Var10=FUNC6(((STRUCT1 *) Var2->memberVar1)->FUNC2()); \nif (Var2->memberVar4 == NULL ){\nFUNC7(Var11,STRING,\nstrerror(Var12)); \nint  Var13=Var14->FUNC8(\nVar15,//Var16\nVar17,//Var17\nVar18,//Var19\nVar20,//Var21\nVar22,//Var23\n&Var24,//Var25\nNULL ,//Var26\nNULL ,//Var27\nNULL ,//Var28\nVar29); //Var30/Var31/STRUCT3  Var32\n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 11, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "chmod", "line": 775, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "    dprintf (D_ALWAYS, \"Skipping %s\\n\", proxy->cred->GetName());\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "    if (now - time_started > 500) {\n", "      daemonCore->Send_Signal (proxy->get_delegation_pid, SIGKILL);\n", "  proxy->get_delegation_proc_start_time = now;\n", "  MyString strBuff;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerDN()) {\n", "    strBuff+= ((X509Credential*)proxy->cred)->GetMyProxyServerDN();\n", "  strBuff+=proxy->GetStorageName();\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (myproxy_password == NULL ) {\n", "    dprintf (D_ALWAYS, \"No MyProxy password specified for %s:%s\\n\",\n\t     proxy->cred->GetName(),\n\t     proxy->cred->GetOwner());\n", "  status = pipe (proxy->get_delegation_password_pipe);\n", "  if (status == -1) {\n", "\tproxy->get_delegation_reset();\n", "  write (proxy->get_delegation_password_pipe[1],\n\t myproxy_password,\n\t strlen (myproxy_password));\n", "  write (proxy->get_delegation_password_pipe[1], \"\\n\", 1);\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if\t(\t((X509Credential*)proxy->cred)->GetCredentialName() && \n  \t\t\t( ((X509Credential*)proxy->cred)->GetCredentialName() )[0] ) {\n", "\t  args.AppendArg(((X509Credential*)proxy->cred)->GetCredentialName());\n", "  proxy->get_delegation_err_filename = create_temp_file();\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tproxy->get_delegation_reset();\n", "  status = chmod (proxy->get_delegation_err_filename, 0600);\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"chmod() get_delegation_err_filename %s failed: %s\\n\",\n\t\t\tproxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_err_fd = safe_open_wrapper_follow(proxy->get_delegation_err_filename,O_RDWR);\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "    dprintf (D_ALWAYS, \"Error opening get_delegation file %s: %s\\n\",\n\t     proxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  int arrIO[3];\n", "  arrIO[0]=proxy->get_delegation_password_pipe[0]; //stdin\n", "  arrIO[2]=proxy->get_delegation_err_fd; // stderr\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  if (pid == FALSE) {\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_pid = pid;\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nFUNC4(Var5,STRING,Var1->memberVar1->FUNC5()); \nSTRUCT3  Var6=FUNC6(NULL ); \nif (Var1->memberVar2 !=  Var7){\nSTRUCT3  Var8=Var1->memberVar3; \nif (Var6-Var8>500){\nVar9->FUNC7(Var1->memberVar2,Var10); \nVar1->memberVar3=Var6; \nSTRUCT4  Var11; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC8()){\nVar11 FUNC9((STRUCT2 *) Var1->memberVar1)->FUNC8(); \nVar11  FUNC9  Var1->FUNC2(); \nconst char *Var12=((STRUCT2 *) Var1->memberVar1)->FUNC10(); \nif (Var12 == NULL ){\nFUNC4(Var5,STRING,\nVar1->memberVar1->FUNC5(),\nVar1->memberVar1->FUNC11()); \nVar4=FUNC12(Var1->memberVar4); \nif (Var4 == -1){\nVar1->FUNC13(); \nwrite(Var1->memberVar4[1],\nVar12,\nstrlen(Var12)); \nwrite(Var1->memberVar4[1],STRING,1); \nconst char *Var13=Var1->memberVar1->FUNC14(); \nVar3=FUNC15(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var14=FUNC16(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT5  Var15; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC17()&&\n(((STRUCT2 *) Var1->memberVar1)->FUNC17())[0]){\nVar15.FUNC18(((STRUCT2 *) Var1->memberVar1)->FUNC17()); \nVar1->memberVar5=FUNC19(); \nif (Var1->memberVar5 == NULL ){\nVar1->FUNC13(); \nVar4=chmod(Var1->memberVar5,0600); \nif (Var4 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nVar1->memberVar6=FUNC20(Var1->memberVar5,Var17); \nif (Var1->memberVar6 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nint  Var18[3]; \nVar18[0]=Var1->memberVar4[0]; //stdin\nVar18[2]=Var1->memberVar6; //Var19\nchar *Var20=FUNC21(STRING); \nif (!Var20){\nint  Var21=Var9->FUNC22(\nVar20,//Var22\nVar15,//Var15\nVar23,//Var24\nVar25,//Var26\nVar27,//Var28\n&Var29,//Var30\nNULL ,//Var31\nNULL ,//Var32\nNULL ,//Var33\nVar18); //Var34/Var35/STRUCT6  Var36\nif (Var21 ==  Var27){\nVar1->FUNC13(); \nVar1->memberVar2=Var21; \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 12, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strerror", "line": 777, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "    dprintf (D_ALWAYS, \"Skipping %s\\n\", proxy->cred->GetName());\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "    if (now - time_started > 500) {\n", "      daemonCore->Send_Signal (proxy->get_delegation_pid, SIGKILL);\n", "  proxy->get_delegation_proc_start_time = now;\n", "  MyString strBuff;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerDN()) {\n", "    strBuff+= ((X509Credential*)proxy->cred)->GetMyProxyServerDN();\n", "  strBuff+=proxy->GetStorageName();\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (myproxy_password == NULL ) {\n", "    dprintf (D_ALWAYS, \"No MyProxy password specified for %s:%s\\n\",\n\t     proxy->cred->GetName(),\n\t     proxy->cred->GetOwner());\n", "  status = pipe (proxy->get_delegation_password_pipe);\n", "  if (status == -1) {\n", "\tproxy->get_delegation_reset();\n", "  write (proxy->get_delegation_password_pipe[1],\n\t myproxy_password,\n\t strlen (myproxy_password));\n", "  write (proxy->get_delegation_password_pipe[1], \"\\n\", 1);\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if\t(\t((X509Credential*)proxy->cred)->GetCredentialName() && \n  \t\t\t( ((X509Credential*)proxy->cred)->GetCredentialName() )[0] ) {\n", "\t  args.AppendArg(((X509Credential*)proxy->cred)->GetCredentialName());\n", "  proxy->get_delegation_err_filename = create_temp_file();\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tproxy->get_delegation_reset();\n", "  status = chmod (proxy->get_delegation_err_filename, 0600);\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"chmod() get_delegation_err_filename %s failed: %s\\n\",\n\t\t\tproxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_err_fd = safe_open_wrapper_follow(proxy->get_delegation_err_filename,O_RDWR);\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "    dprintf (D_ALWAYS, \"Error opening get_delegation file %s: %s\\n\",\n\t     proxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  int arrIO[3];\n", "  arrIO[0]=proxy->get_delegation_password_pipe[0]; //stdin\n", "  arrIO[2]=proxy->get_delegation_err_fd; // stderr\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  if (pid == FALSE) {\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_pid = pid;\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nFUNC4(Var5,STRING,Var1->memberVar1->FUNC5()); \nSTRUCT3  Var6=FUNC6(NULL ); \nif (Var1->memberVar2 !=  Var7){\nSTRUCT3  Var8=Var1->memberVar3; \nif (Var6-Var8>500){\nVar9->FUNC7(Var1->memberVar2,Var10); \nVar1->memberVar3=Var6; \nSTRUCT4  Var11; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC8()){\nVar11 FUNC9((STRUCT2 *) Var1->memberVar1)->FUNC8(); \nVar11  FUNC9  Var1->FUNC2(); \nconst char *Var12=((STRUCT2 *) Var1->memberVar1)->FUNC10(); \nif (Var12 == NULL ){\nFUNC4(Var5,STRING,\nVar1->memberVar1->FUNC5(),\nVar1->memberVar1->FUNC11()); \nVar4=FUNC12(Var1->memberVar4); \nif (Var4 == -1){\nVar1->FUNC13(); \nwrite(Var1->memberVar4[1],\nVar12,\nstrlen(Var12)); \nwrite(Var1->memberVar4[1],STRING,1); \nconst char *Var13=Var1->memberVar1->FUNC14(); \nVar3=FUNC15(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var14=FUNC16(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT5  Var15; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC17()&&\n(((STRUCT2 *) Var1->memberVar1)->FUNC17())[0]){\nVar15.FUNC18(((STRUCT2 *) Var1->memberVar1)->FUNC17()); \nVar1->memberVar5=FUNC19(); \nif (Var1->memberVar5 == NULL ){\nVar1->FUNC13(); \nVar4=chmod(Var1->memberVar5,0600); \nif (Var4 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nVar1->memberVar6=FUNC20(Var1->memberVar5,Var17); \nif (Var1->memberVar6 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nint  Var18[3]; \nVar18[0]=Var1->memberVar4[0]; //stdin\nVar18[2]=Var1->memberVar6; //Var19\nchar *Var20=FUNC21(STRING); \nif (!Var20){\nint  Var21=Var9->FUNC22(\nVar20,//Var22\nVar15,//Var15\nVar23,//Var24\nVar25,//Var26\nVar27,//Var28\n&Var29,//Var30\nNULL ,//Var31\nNULL ,//Var32\nNULL ,//Var33\nVar18); //Var34/Var35/STRUCT6  Var36\nif (Var21 ==  Var27){\nVar1->FUNC13(); \nVar1->memberVar2=Var21; \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 13, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strerror", "line": 786, "label": -3, "slices": ["int RefreshProxyThruMyProxy(X509CredentialWrapper * proxy)\n", "  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "    dprintf (D_ALWAYS, \"Skipping %s\\n\", proxy->cred->GetName());\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "    if (now - time_started > 500) {\n", "      daemonCore->Send_Signal (proxy->get_delegation_pid, SIGKILL);\n", "  proxy->get_delegation_proc_start_time = now;\n", "  MyString strBuff;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerDN()) {\n", "    strBuff+= ((X509Credential*)proxy->cred)->GetMyProxyServerDN();\n", "  strBuff+=proxy->GetStorageName();\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (myproxy_password == NULL ) {\n", "    dprintf (D_ALWAYS, \"No MyProxy password specified for %s:%s\\n\",\n\t     proxy->cred->GetName(),\n\t     proxy->cred->GetOwner());\n", "  status = pipe (proxy->get_delegation_password_pipe);\n", "  if (status == -1) {\n", "\tproxy->get_delegation_reset();\n", "  write (proxy->get_delegation_password_pipe[1],\n\t myproxy_password,\n\t strlen (myproxy_password));\n", "  write (proxy->get_delegation_password_pipe[1], \"\\n\", 1);\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  myproxy_host = getHostFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if\t(\t((X509Credential*)proxy->cred)->GetCredentialName() && \n  \t\t\t( ((X509Credential*)proxy->cred)->GetCredentialName() )[0] ) {\n", "\t  args.AppendArg(((X509Credential*)proxy->cred)->GetCredentialName());\n", "  proxy->get_delegation_err_filename = create_temp_file();\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "\tproxy->get_delegation_reset();\n", "  status = chmod (proxy->get_delegation_err_filename, 0600);\n", "  if (status == -1) {\n", "\tdprintf (D_ALWAYS, \"chmod() get_delegation_err_filename %s failed: %s\\n\",\n\t\t\tproxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_err_fd = safe_open_wrapper_follow(proxy->get_delegation_err_filename,O_RDWR);\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "    dprintf (D_ALWAYS, \"Error opening get_delegation file %s: %s\\n\",\n\t     proxy->get_delegation_err_filename, strerror(errno) );\n", "\tproxy->get_delegation_reset();\n", "  int arrIO[3];\n", "  arrIO[0]=proxy->get_delegation_password_pipe[0]; //stdin\n", "  arrIO[2]=proxy->get_delegation_err_fd; // stderr\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  if (pid == FALSE) {\n", "\tproxy->get_delegation_reset();\n", "  proxy->get_delegation_pid = pid;\n"], "tokenized": "int FUNC1(STRUCT1 *Var1)\nconst char *Var2=Var1->FUNC2(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC3() == NULL ){\nFUNC4(Var5,STRING,Var1->memberVar1->FUNC5()); \nSTRUCT3  Var6=FUNC6(NULL ); \nif (Var1->memberVar2 !=  Var7){\nSTRUCT3  Var8=Var1->memberVar3; \nif (Var6-Var8>500){\nVar9->FUNC7(Var1->memberVar2,Var10); \nVar1->memberVar3=Var6; \nSTRUCT4  Var11; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC8()){\nVar11 FUNC9((STRUCT2 *) Var1->memberVar1)->FUNC8(); \nVar11  FUNC9  Var1->FUNC2(); \nconst char *Var12=((STRUCT2 *) Var1->memberVar1)->FUNC10(); \nif (Var12 == NULL ){\nFUNC4(Var5,STRING,\nVar1->memberVar1->FUNC5(),\nVar1->memberVar1->FUNC11()); \nVar4=FUNC12(Var1->memberVar4); \nif (Var4 == -1){\nVar1->FUNC13(); \nwrite(Var1->memberVar4[1],\nVar12,\nstrlen(Var12)); \nwrite(Var1->memberVar4[1],STRING,1); \nconst char *Var13=Var1->memberVar1->FUNC14(); \nVar3=FUNC15(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nint  Var14=FUNC16(((STRUCT2 *) Var1->memberVar1)->FUNC3()); \nSTRUCT5  Var15; \nif (((STRUCT2 *) Var1->memberVar1)->FUNC17()&&\n(((STRUCT2 *) Var1->memberVar1)->FUNC17())[0]){\nVar15.FUNC18(((STRUCT2 *) Var1->memberVar1)->FUNC17()); \nVar1->memberVar5=FUNC19(); \nif (Var1->memberVar5 == NULL ){\nVar1->FUNC13(); \nVar4=chmod(Var1->memberVar5,0600); \nif (Var4 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nVar1->memberVar6=FUNC20(Var1->memberVar5,Var17); \nif (Var1->memberVar6 == -1){\nFUNC4(Var5,STRING,\nVar1->memberVar5,strerror(Var16)); \nVar1->FUNC13(); \nint  Var18[3]; \nVar18[0]=Var1->memberVar4[0]; //stdin\nVar18[2]=Var1->memberVar6; //Var19\nchar *Var20=FUNC21(STRING); \nif (!Var20){\nint  Var21=Var9->FUNC22(\nVar20,//Var22\nVar15,//Var15\nVar23,//Var24\nVar25,//Var26\nVar27,//Var28\n&Var29,//Var30\nNULL ,//Var31\nNULL ,//Var32\nNULL ,//Var33\nVar18); //Var34/Var35/STRUCT6  Var36\nif (Var21 ==  Var27){\nVar1->FUNC13(); \nVar1->memberVar2=Var21; \n"}, {"FileName": "credd_before.cpp", "Caller": "RefreshProxyThruMyProxy", "Source": false, "Sink": false, "idx": 14, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "free", "line": 822, "label": -3, "slices": ["  const char * proxy_filename = proxy->GetStorageName();\n", "  char * myproxy_host = NULL;\n", "  int status;\n", "  if (((X509Credential*)proxy->cred)->GetMyProxyServerHost() == NULL) {\n", "  time_t now = time(NULL);\n", "  if (proxy->get_delegation_pid != GET_DELEGATION_PID_NONE) {\n", "    time_t time_started = proxy->get_delegation_proc_start_time;\n", "  const char * myproxy_password =((X509Credential*)proxy->cred)->GetRefreshPassword();\n", "  if (status == -1) {\n", "  const char * username = proxy->cred->GetOrigOwner();\n", "  int myproxy_port = getPortFromAddr (((X509Credential*)proxy->cred)->GetMyProxyServerHost());\n", "  ArgList args;\n", "  if (proxy->get_delegation_err_filename == NULL) {\n", "  if (status == -1) {\n", "  if (proxy->get_delegation_err_fd == -1) {\n", "  int arrIO[3];\n", "  char * myproxy_get_delegation_pgm = param (\"MYPROXY_GET_DELEGATION\");\n", "  if (!myproxy_get_delegation_pgm) {\n", "  MyString args_string;\n", "  dprintf (D_ALWAYS, \"Calling %s %s\\n\", myproxy_get_delegation_pgm, args_string.Value());\n", "  int pid = daemonCore->Create_Process (\n\t\t\t\t\tmyproxy_get_delegation_pgm,\t\t// name\n\t\t\t\t\targs,\t\t\t\t \t\t\t// args\n\t\t\t\t\tPRIV_USER_FINAL,\t\t\t\t// priv\n\t\t\t\t\tmyproxyGetDelegationReaperId,\t// reaper_id\n\t\t\t\t\tFALSE,\t\t\t\t\t\t\t// want_command_port\n\t\t\t\t\t&myEnv,\t\t\t\t\t\t\t// env\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// cwd\t\t\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// family_info\n\t\t\t\t\tNULL,\t\t\t\t\t\t\t// sock_inherit_list\n\t\t\t\t\tarrIO);\t\t\t\t\t\t\t// in/out/err streams\n", "  free (myproxy_get_delegation_pgm);\n"], "tokenized": "const char *Var1=Var2->FUNC1(); \nchar *Var3=NULL ; \nint  Var4; \nif (((STRUCT1 *) Var2->memberVar1)->FUNC2() == NULL ){\nSTRUCT2  Var5=FUNC3(NULL ); \nif (Var2->memberVar2 !=  Var6){\nSTRUCT2  Var7=Var2->memberVar3; \nconst char *Var8=((STRUCT1 *) Var2->memberVar1)->FUNC4(); \nif (Var4 == -1){\nconst char *Var9=Var2->memberVar1->FUNC5(); \nint  Var10=FUNC6(((STRUCT1 *) Var2->memberVar1)->FUNC2()); \nSTRUCT3  Var11; \nif (Var2->memberVar4 == NULL ){\nif (Var4 == -1){\nif (Var2->STRUCT4 == -1){\nint  Var12[3]; \nchar *Var13=FUNC7(STRING); \nif (!Var13){\nSTRUCT5  Var14; \nFUNC8(Var15,STRING,Var13,Var14.FUNC9()); \nint  Var16=Var17->FUNC10(\nVar13,//Var18\nVar11,//Var11\nVar19,//Var20\nVar21,//Var22\nVar23,//Var24\n&Var25,//Var26\nNULL ,//Var27\nNULL ,//Var28\nNULL ,//Var29\nVar12); //Var30/Var31/STRUCT6  Var32\nfree(Var13); \n"}, {"FileName": "credd_before.cpp", "Caller": "isSuperUser", "Source": false, "Sink": false, "idx": 15, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 957, "label": -3, "slices": ["isSuperUser( const char* user )\n", "  if( ! (user)) {\n", "  char * next;\n", "  while ((next = super_users.next())) {\n", "    if (strcmp (user, next ) == 0) {\n"], "tokenized": "FUNC1(const char *Var1)\nif (!(Var1)){\nchar *Var2; \nwhile ((Var2=Var3.Var2())){\nif (strcmp(Var1,Var2) == 0){\n"}, {"FileName": "credd_before.cpp", "Caller": "Init", "Source": false, "Sink": false, "idx": 16, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "free", "line": 971, "label": -3, "slices": ["  char * tmp = param( \"CRED_SUPER_USERS\" );\n", "  if( tmp ) {\n", "    super_users.initializeFromString( tmp );\n", "    free( tmp );\n", "  char * spool = param (\"SPOOL\");\n"], "tokenized": "char *Var1=FUNC1(STRING); \nif (Var1){\nVar2.FUNC2(Var1); \nfree(Var1); \nchar *Var3=FUNC1(STRING); \n"}, {"FileName": "credd_before.cpp", "Caller": "Init", "Source": false, "Sink": false, "idx": 17, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "free", "line": 989, "label": -3, "slices": ["  char * tmp = param( \"CRED_SUPER_USERS\" );\n", "  char * spool = param (\"SPOOL\");\n", "  if ( tmp ) {\n", "else\n", "    cred_store_dir = dircat (spool, \"cred\");\n", "  if ( spool != NULL ) {\n", "\t  free (spool);\n"], "tokenized": "char *Var1=FUNC1(STRING); \nchar *Var2=FUNC1(STRING); \nif (Var1){\nelse \nVar3=FUNC2(Var2,STRING); \nif (Var2 != NULL ){\nfree(Var2); \n"}, {"FileName": "credd_before.cpp", "Caller": "Init", "Source": false, "Sink": false, "idx": 18, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "close", "line": 1020, "label": -3, "slices": ["  char * tmp = param( \"CRED_SUPER_USERS\" );\n", "  char * spool = param (\"SPOOL\");\n", "  tmp = param ( \"CRED_STORE_DIR\" );\n", "  if ( tmp ) {\n", "    cred_store_dir = tmp;\n", "else\n", "    cred_store_dir = dircat (spool, \"cred\");\n", "  tmp = param ( \"CRED_INDEX_FILE\" );\n", "  if (tmp ) {\n", "    cred_index_file = tmp;\n", "else\n", "    cred_index_file = dircat (cred_store_dir, \"cred-index\");\n", "  if (stat (cred_index_file, &stat_buff)) {\n", "    int fd = safe_open_wrapper_follow(cred_index_file, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n", "    if (fd != -1) {\n", "      close (fd);\n"], "tokenized": "char *Var1=FUNC1(STRING); \nchar *Var2=FUNC1(STRING); \nVar1=FUNC1(STRING); \nif (Var1){\nVar3=Var1; \nelse \nVar3=FUNC2(Var2,STRING); \nVar1=FUNC1(STRING); \nif (Var1){\nVar4=Var1; \nelse \nVar4=FUNC2(Var3,STRING); \nif (FUNC3(Var4,&Var5)){\nint  Var6=FUNC4(Var4,Var7|Var8|Var9,0600); \nif (Var6 != -1){\nclose(Var6); \n"}, {"FileName": "credd_before.cpp", "Caller": "StoreData", "Source": false, "Sink": false, "idx": 19, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "write", "line": 1060, "label": -3, "slices": ["StoreData (const char * file_name, const void * data, const int data_size) {\n", "  if (!data) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_WRONLY | O_CREAT | O_TRUNC, 0600 );\n", "  if (fd == -1) {\n", "  fchmod (fd, S_IRUSR | S_IWUSR);\n", "  fchown (fd, get_user_uid(), get_user_gid());\n", "  write (fd, data, data_size);\n", "  close (fd);\n"], "tokenized": "FUNC1(const char *Var1,const void *Var2,const int  Var3){\nif (!Var2){\nint  Var4=FUNC2(Var1,Var5|Var6|Var7,0600); \nif (Var4 == -1){\nFUNC3(Var4,Var8|Var9); \nFUNC4(Var4,FUNC5(),FUNC6()); \nwrite(Var4,Var2,Var3); \nclose(Var4); \n"}, {"FileName": "credd_before.cpp", "Caller": "StoreData", "Source": false, "Sink": false, "idx": 20, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "close", "line": 1062, "label": -3, "slices": ["StoreData (const char * file_name, const void * data, const int data_size) {\n", "  if (!data) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_WRONLY | O_CREAT | O_TRUNC, 0600 );\n", "  if (fd == -1) {\n", "  fchmod (fd, S_IRUSR | S_IWUSR);\n", "  fchown (fd, get_user_uid(), get_user_gid());\n", "  write (fd, data, data_size);\n", "  close (fd);\n"], "tokenized": "FUNC1(const char *Var1,const void *Var2,const int  Var3){\nif (!Var2){\nint  Var4=FUNC2(Var1,Var5|Var6|Var7,0600); \nif (Var4 == -1){\nFUNC3(Var4,Var8|Var9); \nFUNC4(Var4,FUNC5(),FUNC6()); \nwrite(Var4,Var2,Var3); \nclose(Var4); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadData", "Source": false, "Sink": false, "idx": 21, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "fprintf", "line": 1074, "label": -3, "slices": ["LoadData (const char * file_name, void *& data, int & data_size) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_RDONLY);\n", "  if (fd == -1) {\n", "    fprintf (stderr, \"Can't open %s\\n\", file_name);\n"], "tokenized": "FUNC1(const char *Var1,void *&Var2,int &Var3){\nint  Var4=FUNC2(Var1,Var5); \nif (Var4 == -1){\nfprintf(Var6,STRING,Var1); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadData", "Source": false, "Sink": false, "idx": 22, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "read", "line": 1080, "label": -3, "slices": ["LoadData (const char * file_name, void *& data, int & data_size) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_RDONLY);\n", "  if (fd == -1) {\n", "  char buff [MAX_CRED_DATA_SIZE+1];\n", "  data_size = read (fd, buff, MAX_CRED_DATA_SIZE);\n", "  close (fd);\n", "  if (data_size <= 0) {\n", "  data = malloc (data_size);\n", "  memcpy (data, buff, data_size);\n"], "tokenized": "FUNC1(const char *Var1,void *&Var2,int &Var3){\nint  Var4=FUNC2(Var1,Var5); \nif (Var4 == -1){\nchar  Var6[Var7+1]; \nVar3=read(Var4,Var6,Var7); \nclose(Var4); \nif (Var3 <= 0){\nVar2=malloc(Var3); \nmemcpy(Var2,Var6,Var3); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadData", "Source": false, "Sink": false, "idx": 23, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "close", "line": 1082, "label": -3, "slices": ["LoadData (const char * file_name, void *& data, int & data_size) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_RDONLY);\n", "  if (fd == -1) {\n", "  char buff [MAX_CRED_DATA_SIZE+1];\n", "  data_size = read (fd, buff, MAX_CRED_DATA_SIZE);\n", "  close (fd);\n"], "tokenized": "FUNC1(const char *Var1,void *&Var2,int &Var3){\nint  Var4=FUNC2(Var1,Var5); \nif (Var4 == -1){\nchar  Var6[Var7+1]; \nVar3=read(Var4,Var6,Var7); \nclose(Var4); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadData", "Source": false, "Sink": false, "idx": 24, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "malloc", "line": 1089, "label": -3, "slices": ["LoadData (const char * file_name, void *& data, int & data_size) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_RDONLY);\n", "  if (fd == -1) {\n", "  char buff [MAX_CRED_DATA_SIZE+1];\n", "  data_size = read (fd, buff, MAX_CRED_DATA_SIZE);\n", "  if (data_size <= 0) {\n", "  data = malloc (data_size);\n", "  memcpy (data, buff, data_size);\n"], "tokenized": "FUNC1(const char *Var1,void *&Var2,int &Var3){\nint  Var4=FUNC2(Var1,Var5); \nif (Var4 == -1){\nchar  Var6[Var7+1]; \nVar3=read(Var4,Var6,Var7); \nif (Var3 <= 0){\nVar2=malloc(Var3); \nmemcpy(Var2,Var6,Var3); \n"}, {"FileName": "credd_before.cpp", "Caller": "LoadData", "Source": false, "Sink": false, "idx": 25, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 1091, "label": -3, "slices": ["LoadData (const char * file_name, void *& data, int & data_size) {\n", "  int fd = safe_open_wrapper_follow(file_name, O_RDONLY);\n", "  if (fd == -1) {\n", "  char buff [MAX_CRED_DATA_SIZE+1];\n", "  data_size = read (fd, buff, MAX_CRED_DATA_SIZE);\n", "  if (data_size <= 0) {\n", "  data = malloc (data_size);\n", "  memcpy (data, buff, data_size);\n"], "tokenized": "FUNC1(const char *Var1,void *&Var2,int &Var3){\nint  Var4=FUNC2(Var1,Var5); \nif (Var4 == -1){\nchar  Var6[Var7+1]; \nVar3=read(Var4,Var6,Var7); \nif (Var3 <= 0){\nVar2=malloc(Var3); \nmemcpy(Var2,Var6,Var3); \n"}, {"FileName": "credd_before.cpp", "Caller": "init_user_id_from_FQN", "Source": false, "Sink": false, "idx": 26, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strdup", "line": 1108, "label": -3, "slices": ["init_user_id_from_FQN (const char * _fqn) {\n", "  char * uid = NULL;\n", "  char * domain = NULL;\n", "  char * fqn = NULL;\n", "  if (_fqn) {\n", "    fqn = strdup (_fqn);\n", "    uid = fqn;\n", "    char * pAt = strchr (fqn, '@');\n", "    if (pAt) {\n", "      *pAt='\\0';\n", "      domain = pAt+1;\n", "  int rc = init_user_ids (uid, domain);\n", "  dprintf (D_FULLDEBUG, \"Switching to user %s@%s, result = %d\\n\", uid, domain, rc);\n", "  if (fqn)\n", "    free (fqn);\n", "  return rc;\n"], "tokenized": "FUNC1(const char *Var1){\nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nif (Var1){\nVar4=strdup(Var1); \nVar2=Var4; \nchar *Var5=strchr(Var4,); \nif (Var5){\n*Var5=0; \nVar3=Var5+1; \nint  Var6=FUNC2(Var2,Var3); \nFUNC3(Var7,STRING,Var2,Var3,Var6); \nif (Var4)\nfree(Var4); \nreturn  Var6; \n"}, {"FileName": "credd_before.cpp", "Caller": "init_user_id_from_FQN", "Source": false, "Sink": false, "idx": 27, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1112, "label": -3, "slices": ["init_user_id_from_FQN (const char * _fqn) {\n", "  char * uid = NULL;\n", "  char * domain = NULL;\n", "  char * fqn = NULL;\n", "  if (_fqn) {\n", "    fqn = strdup (_fqn);\n", "    uid = fqn;\n", "    char * pAt = strchr (fqn, '@');\n", "    if (pAt) {\n", "      *pAt='\\0';\n", "      domain = pAt+1;\n", "  int rc = init_user_ids (uid, domain);\n", "  dprintf (D_FULLDEBUG, \"Switching to user %s@%s, result = %d\\n\", uid, domain, rc);\n", "  if (fqn)\n", "    free (fqn);\n", "  return rc;\n"], "tokenized": "FUNC1(const char *Var1){\nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nif (Var1){\nVar4=strdup(Var1); \nVar2=Var4; \nchar *Var5=strchr(Var4,); \nif (Var5){\n*Var5=0; \nVar3=Var5+1; \nint  Var6=FUNC2(Var2,Var3); \nFUNC3(Var7,STRING,Var2,Var3,Var6); \nif (Var4)\nfree(Var4); \nreturn  Var6; \n"}, {"FileName": "credd_before.cpp", "Caller": "init_user_id_from_FQN", "Source": false, "Sink": false, "idx": 28, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "free", "line": 1127, "label": -3, "slices": ["init_user_id_from_FQN (const char * _fqn) {\n", "  char * uid = NULL;\n", "  char * domain = NULL;\n", "  char * fqn = NULL;\n", "  if (_fqn) {\n", "    fqn = strdup (_fqn);\n", "    uid = fqn;\n", "    char * pAt = strchr (fqn, '@');\n", "  int rc = init_user_ids (uid, domain);\n", "  if (fqn)\n", "    free (fqn);\n"], "tokenized": "FUNC1(const char *Var1){\nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nif (Var1){\nVar4=strdup(Var1); \nVar2=Var4; \nchar *Var5=strchr(Var4,); \nint  Var6=FUNC2(Var2,Var3); \nif (Var4)\nfree(Var4); \n"}]